<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="theme-color" content="#1a1a2e">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Alice Display</title>
    <link rel="manifest" href="manifest.json">
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="styles-responsive.css">
    <style>
        /* Critical path CSS for instant render - full styles in external files */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        html, body { height: 100%; width: 100%; overflow: hidden; position: fixed; }
        body { 
            background: #1a1a2e; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex; justify-content: center; align-items: center;
        }
        .display-container { width: 100vw; height: 100vh; height: 100dvh; overflow: hidden; }
        .image-layer { position: absolute; inset: 0; display: flex; justify-content: center; align-items: center; }
        .image-layer.inactive { opacity: 0; }
        .image-layer img { max-width: 100%; max-height: 100%; object-fit: contain; }
        .loading-spinner { position: fixed; inset: 0; display: none; }
        .loading-spinner.active { display: flex; justify-content: center; align-items: center; }
        .spinner { width: 50px; height: 50px; border: 3px solid rgba(255,255,255,0.1); border-top-color: #fff; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="display-container">
        <div class="image-layer active" id="layer-a">
            <img src="" alt="Alice">
        </div>
        <div class="image-layer inactive" id="layer-b">
            <img src="" alt="Alice">
        </div>
    </div>
    
    <div class="title-overlay" id="title-overlay"></div>
    
    <!-- Weather Widget Overlay -->
    <div class="weather-widget" id="weather-widget">
        <div class="weather-widget-header">
            <span class="weather-widget-icon" id="widget-weather-icon">‚òÄÔ∏è</span>
            <div>
                <div class="weather-widget-temp">
                    <span id="widget-temp">--</span><span class="unit">¬∞C</span>
                </div>
            </div>
        </div>
        <div class="weather-widget-condition" id="widget-condition">Loading...</div>
        <div class="weather-widget-description" id="widget-description">--</div>
        <div class="weather-widget-divider"></div>
        <div class="weather-widget-details">
            <div class="weather-widget-detail">
                <div class="weather-widget-detail-value" id="widget-humidity">--%</div>
                <div class="weather-widget-detail-label">Humidity</div>
            </div>
            <div class="weather-widget-detail">
                <div class="weather-widget-detail-value" id="widget-activity">--</div>
                <div class="weather-widget-detail-label">Activity</div>
            </div>
        </div>
        <div class="weather-widget-time">
            <span class="weather-widget-clock" id="widget-clock">--:--</span>
            <span class="weather-widget-period" id="widget-period">--</span>
        </div>
    </div>
    
    <!-- Standalone clock for mobile portrait ‚Äî fills the top-right dead space -->
    <div class="portrait-clock" id="portrait-clock">
        <span class="portrait-clock-time" id="portrait-clock-time">--:--</span>
        <span class="portrait-clock-period" id="portrait-clock-period">--</span>
    </div>
    
    <!-- Standalone clock for mobile landscape ‚Äî small format bottom-right -->
    <div class="landscape-clock" id="landscape-clock" style="display: none;">
        <span class="landscape-clock-time" id="landscape-clock-time">--:--</span>
        <span class="landscape-clock-period" id="landscape-clock-period">--</span>
    </div>
    
    <div class="status-overlay" id="status-overlay">
        <div class="status-item">
            <span class="icon" id="weather-icon">‚òÄÔ∏è</span>
            <div>
                <div class="value" id="weather-condition">Loading...</div>
                <div class="label" id="temperature">--¬∞C</div>
            </div>
        </div>
        <div class="status-item">
            <span class="icon">üïê</span>
            <div>
                <div class="value" id="time-period">--</div>
                <div class="label" id="current-time">--:--</div>
            </div>
        </div>
        <div class="status-item" id="activity-item">
            <span class="icon">üé®</span>
            <div>
                <div class="value" id="activity">--</div>
            </div>
        </div>
        <div class="copy-toast" id="copy-toast">üìã Copied!</div>
    </div>
    
    <div class="countdown" id="countdown"></div>
    
    <div class="update-indicator" id="update-indicator">‚ú® Updated!</div>
    
    <div class="loading-spinner" id="loading-spinner">
        <div class="spinner"></div>
    </div>
    
    <div class="error-message" id="error-message">
        <div class="error-icon">ü¶ú</div>
        <div class="error-title" id="error-title">Connection Issue</div>
        <div class="error-detail" id="error-detail">Unable to load display data</div>
        <div class="error-retry-counter" id="error-retry-counter">Retry 0/10</div>
        <div class="error-retry">Retrying in <span class="countdown" id="error-countdown">10</span>s</div>
    </div>
    
    <div class="connection-status" id="connection-status">
        <div class="connection-dot"></div>
        <span id="connection-text">Connected</span>
    </div>
    
    <div class="fallback-badge" id="fallback-badge">‚ö†Ô∏è Showing cached image</div>
    
    <div class="debug-panel" id="debug-panel">
        <pre id="debug-content"></pre>
    </div>
    
    <button class="fullscreen-btn" id="fullscreen-btn" title="Toggle Fullscreen">‚õ∂</button>
    
    <!-- PWA Install Banner -->
    <div class="install-banner" id="install-banner">
        <div class="install-banner-content">
            <div class="install-banner-icon">ü¶ú</div>
            <div class="install-banner-text">
                <div class="install-banner-title">Install Alice Display</div>
                <div class="install-banner-subtitle">Add to home screen for fullscreen experience</div>
            </div>
        </div>
        <div class="install-banner-actions">
            <button class="dismiss-btn" id="install-dismiss">Maybe Later</button>
            <button class="install-btn" id="install-btn">Install</button>
        </div>
    </div>
    
    <!-- iOS Install Instructions -->
    <div class="ios-modal" id="ios-modal">
        <div class="ios-modal-content">
            <div class="ios-modal-icon">ü¶ú</div>
            <div class="ios-modal-title">Install Alice Display</div>
            <div class="ios-modal-subtitle">Add to your home screen for the best experience</div>
            
            <div class="ios-modal-steps">
                <div class="ios-modal-step">
                    <span class="ios-step-number">1</span>
                    <div class="ios-step-content">
                        <div class="ios-step-title">Tap <span class="ios-share-icon">‚¨ÜÔ∏è Share</span></div>
                        <div class="ios-step-desc">Find it at the bottom of Safari</div>
                    </div>
                </div>
                <div class="ios-modal-step">
                    <span class="ios-step-number">2</span>
                    <div class="ios-step-content">
                        <div class="ios-step-title">Add to Home Screen</div>
                        <div class="ios-step-desc">Scroll down in the share menu</div>
                    </div>
                </div>
                <div class="ios-modal-step">
                    <span class="ios-step-number">3</span>
                    <div class="ios-step-content">
                        <div class="ios-step-title">Tap "Add"</div>
                        <div class="ios-step-desc">Confirm in the top right corner</div>
                    </div>
                </div>
            </div>
            
            <div class="ios-modal-buttons">
                <button class="ios-modal-close" id="ios-modal-close">Got it!</button>
                <button class="ios-modal-dismiss" id="ios-modal-dismiss">Don't show again</button>
            </div>
            
            <div class="ios-safari-note">
                <strong>Note:</strong> Must be opened in Safari. Other browsers don't support home screen apps.
            </div>
        </div>
    </div>
    
    <!-- Help Overlay -->
    <div class="help-overlay" id="help-overlay">
        <div class="help-content">
            <div class="help-title">‚å®Ô∏è Keyboard Shortcuts</div>
            <div class="help-shortcuts">
                <span class="help-key">R</span>
                <span class="help-desc">Refresh display</span>
                
                <span class="help-key">F</span>
                <span class="help-desc">Toggle fullscreen</span>
                
                <span class="help-key">S</span>
                <span class="help-desc">Toggle status overlay</span>
                
                <span class="help-key">Space</span>
                <span class="help-desc">Pause/resume auto-refresh</span>
                
                <span class="help-key">I</span>
                <span class="help-desc">Show image info</span>
                
                <span class="help-key">W</span>
                <span class="help-desc">Toggle status overlay</span>
                
                <span class="help-key">Ctrl+D</span>
                <span class="help-desc">Toggle debug panel</span>
                
                <span class="help-key">H / ?</span>
                <span class="help-desc">Show this help</span>
                
                <span class="help-key">Shift+R</span>
                <span class="help-desc">Report issue with image</span>
                
                <span class="help-key">Esc</span>
                <span class="help-desc">Close panels</span>
            </div>
            <div class="help-close">Press any key to close</div>
        </div>
    </div>
    
    <!-- Toast notification -->
    <div class="toast" id="toast"></div>
    
    <!-- Pause indicator -->
    <div class="pause-indicator" id="pause-indicator">
        ‚è∏Ô∏è Auto-refresh paused ‚Äî Press Space to resume
    </div>
    
    <!-- Image info panel -->
    <div class="image-info" id="image-info">
        <h3>üñºÔ∏è Image Info</h3>
        <div class="image-info-row">
            <span class="image-info-label">Title</span>
            <span class="image-info-value" id="info-title">--</span>
        </div>
        <div class="image-info-row">
            <span class="image-info-label">Weather</span>
            <span class="image-info-value" id="info-weather">--</span>
        </div>
        <div class="image-info-row">
            <span class="image-info-label">Time</span>
            <span class="image-info-value" id="info-time">--</span>
        </div>
        <div class="image-info-row">
            <span class="image-info-label">Activity</span>
            <span class="image-info-value" id="info-activity">--</span>
        </div>
        <div class="image-info-row">
            <span class="image-info-label">Updated</span>
            <span class="image-info-value" id="info-updated">--</span>
        </div>
    </div>
    
    <!-- Report Issue Button -->
    <!-- Command Center -->
    <!-- Inline style forces position in footer -->
    <div class="command-center" id="command-center" style="bottom: 15px !important; top: auto !important;">
        <div class="command-center-popup">
            <button class="command-center-icon lights" id="cmd-lights" title="Lights">üí°</button>
            <button class="command-center-icon vacuum" id="cmd-vacuum" title="Vacuum">ü§ñ</button>
            <button class="command-center-icon image" id="cmd-image" title="Image Controls">üñºÔ∏è</button>
            <button class="command-center-icon about" id="cmd-about" title="About/Debug">‚ÑπÔ∏è</button>
        </div>
        <button class="command-center-button" id="command-center-button" title="Command Center">‚öôÔ∏è</button>
    </div>
    <div class="command-center-backdrop" id="command-center-backdrop"></div>
    
    <!-- Image Control Panel -->
    <div class="image-control-panel" id="image-control-panel">
        <div class="image-control-header">
            <span class="image-control-title">üñºÔ∏è Image Controls</span>
            <button class="image-control-close" id="image-control-close" title="Close">‚úï</button>
        </div>
        <div class="image-control-buttons">
            <button class="image-control-btn change" id="img-change">
                <span class="image-control-btn-icon">üîÑ</span>
                <span class="image-control-btn-text">Change Image</span>
            </button>
            <button class="image-control-btn report" id="img-report">
                <span class="image-control-btn-icon">üö©</span>
                <span class="image-control-btn-text">Report Issue</span>
            </button>
            <div class="image-control-rating-row">
                <button class="image-control-btn like" id="img-like">
                    <span class="image-control-btn-icon">üëç</span>
                    <span class="image-control-btn-text">Like</span>
                </button>
                <button class="image-control-btn dislike" id="img-dislike">
                    <span class="image-control-btn-icon">üëé</span>
                    <span class="image-control-btn-text">Dislike</span>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Desktop Info Panel (Right Sidebar) -->
    <div class="desktop-info-panel" id="desktop-info-panel" style="display: none;">
        <div class="desktop-info-title">
            üìä Image Information
        </div>
        
        <div class="desktop-info-section">
            <div class="desktop-info-section-title">Current Image</div>
            <div class="desktop-info-item">
                <span class="desktop-info-label">Title:</span>
                <span class="desktop-info-value" id="desktop-info-title">--</span>
            </div>
            <div class="desktop-info-item">
                <span class="desktop-info-label">Updated:</span>
                <span class="desktop-info-value" id="desktop-info-updated">--</span>
            </div>
            <div class="desktop-info-item">
                <span class="desktop-info-label">Source:</span>
                <span class="desktop-info-value" id="desktop-info-source">Gallery</span>
            </div>
        </div>
        
        <div class="desktop-info-section">
            <div class="desktop-info-section-title">Context</div>
            <div class="desktop-info-item">
                <span class="desktop-info-label">Time:</span>
                <span class="desktop-info-value" id="desktop-info-time">--</span>
            </div>
            <div class="desktop-info-item">
                <span class="desktop-info-label">Activity:</span>
                <span class="desktop-info-value" id="desktop-info-activity">--</span>
            </div>
            <div class="desktop-info-item">
                <span class="desktop-info-label">Weather:</span>
                <span class="desktop-info-value" id="desktop-info-weather">--</span>
            </div>
        </div>
        
        <div class="desktop-info-section">
            <div class="desktop-info-section-title">System</div>
            <div class="desktop-info-item">
                <span class="desktop-info-label">Layout:</span>
                <span class="desktop-info-value" id="desktop-info-layout">Desktop</span>
            </div>
            <div class="desktop-info-item">
                <span class="desktop-info-label">Screen:</span>
                <span class="desktop-info-value" id="desktop-info-screen">--</span>
            </div>
            <div class="desktop-info-item">
                <span class="desktop-info-label">Connection:</span>
                <span class="desktop-info-value" id="desktop-info-connection">Online</span>
            </div>
        </div>
    </div>
    <div class="image-control-backdrop" id="image-control-backdrop"></div>
    
    <!-- Vacuum Control Panel -->
    <div class="vacuum-panel" id="vacuum-panel">
        <div class="vacuum-panel-content">
            <div class="vacuum-panel-header">
                <h2 class="vacuum-panel-title">ü§ñ Yiko Vacuum</h2>
                <button class="vacuum-panel-close" id="vacuum-panel-close" title="Close">‚úï</button>
            </div>
            
            <div class="vacuum-battery" id="vacuum-battery">
                <span class="vacuum-battery-icon" id="vacuum-battery-icon">üîã</span>
                <span class="vacuum-battery-text" id="vacuum-battery-text">Loading...</span>
            </div>
            
            <div class="vacuum-status" id="vacuum-status">
                <span class="vacuum-status-icon" id="vacuum-status-icon">üìç</span>
                <span class="vacuum-status-text" id="vacuum-status-text">--</span>
            </div>
            
            <div class="vacuum-actions">
                <button class="vacuum-btn vacuum-btn-start" id="vacuum-btn-start">
                    <span class="vacuum-btn-icon">‚ñ∂Ô∏è</span>
                    <span>Start Cleaning</span>
                </button>
                <button class="vacuum-btn vacuum-btn-stop" id="vacuum-btn-stop">
                    <span class="vacuum-btn-icon">‚èπÔ∏è</span>
                    <span>Stop</span>
                </button>
                <button class="vacuum-btn vacuum-btn-home" id="vacuum-btn-home">
                    <span class="vacuum-btn-icon">üè†</span>
                    <span>Go Home</span>
                </button>
            </div>
        </div>
    </div>
    
    <!-- Lights Control Panel -->
    <div class="lights-panel" id="lights-panel">
        <div class="lights-panel-content">
            <div class="lights-panel-header">
                <h2 class="lights-panel-title">üí° Lights Control</h2>
                <button class="lights-panel-close" id="lights-panel-close" title="Close">‚úï</button>
            </div>
            
            <div class="lights-presets">
                <button class="lights-preset-btn bedtime" id="lights-bedtime">
                    <span class="lights-preset-icon">üåô</span>
                    <span class="lights-preset-text">Bedtime</span>
                    <span class="lights-preset-desc">All lights to 1%</span>
                </button>
                <button class="lights-preset-btn daytime" id="lights-daytime">
                    <span class="lights-preset-icon">‚òÄÔ∏è</span>
                    <span class="lights-preset-text">Daytime</span>
                    <span class="lights-preset-desc">All lights to 100%</span>
                </button>
                <button class="lights-preset-btn movie" id="lights-movie">
                    <span class="lights-preset-icon">üé¨</span>
                    <span class="lights-preset-text">Movie Mode</span>
                    <span class="lights-preset-desc">30% + Blue</span>
                </button>
            </div>
        </div>
    </div>
    
    <!-- About/Debug Panel -->
    <div class="about-panel" id="about-panel">
        <div class="about-panel-header">
            <h2 class="about-panel-title">‚ÑπÔ∏è About</h2>
            <button class="about-panel-close" id="about-panel-close" title="Close">‚úï</button>
        </div>
        <div class="about-info">
            <div class="about-info-section">
                <div class="about-info-section-title">Version</div>
                <div class="about-info-row">
                    <span class="about-info-label">Commit:</span>
                    <span class="about-info-value" id="about-version-commit">Loading...</span>
                </div>
                <div class="about-info-row">
                    <span class="about-info-label">Deployed:</span>
                    <span class="about-info-value" id="about-version-deployed">Loading...</span>
                </div>
            </div>
            
            <div class="about-info-section">
                <div class="about-info-section-title">Current Image</div>
                <div class="about-info-row">
                    <span class="about-info-label">Filename:</span>
                    <span class="about-info-value" id="about-image-filename">--</span>
                </div>
                <div class="about-info-row">
                    <span class="about-info-label">Activity:</span>
                    <span class="about-info-value" id="about-image-activity">--</span>
                </div>
            </div>
            
            <div class="about-info-section">
                <div class="about-info-section-title">Context</div>
                <div class="about-info-row">
                    <span class="about-info-label">Weather:</span>
                    <span class="about-info-value" id="about-weather">--</span>
                </div>
                <div class="about-info-row">
                    <span class="about-info-label">Temperature:</span>
                    <span class="about-info-value" id="about-temperature">--</span>
                </div>
                <div class="about-info-row">
                    <span class="about-info-label">Time Period:</span>
                    <span class="about-info-value" id="about-time-period">--</span>
                </div>
                <div class="about-info-row">
                    <span class="about-info-label">Last Update:</span>
                    <span class="about-info-value" id="about-last-update">--</span>
                </div>
            </div>
            
            <div class="about-info-section">
                <div class="about-info-section-title">System</div>
                <div class="about-info-row">
                    <span class="about-info-label">Screen:</span>
                    <span class="about-info-value" id="about-screen">--</span>
                </div>
                <div class="about-info-row">
                    <span class="about-info-label">Browser:</span>
                    <span class="about-info-value" id="about-browser">--</span>
                </div>
                <div class="about-info-row">
                    <span class="about-info-label">Platform:</span>
                    <span class="about-info-value" id="about-platform">--</span>
                </div>
                <div class="about-info-row">
                    <span class="about-info-label">Connection:</span>
                    <span class="about-info-value" id="about-connection">--</span>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Report Issue Modal -->
    <div class="report-modal" id="report-modal">
        <div class="report-modal-content">
            <div class="report-modal-header">
                <h2 class="report-modal-title">üö© Report Issue</h2>
                <button class="report-modal-close" id="report-modal-close" title="Close">‚úï</button>
            </div>
            
            <form class="report-form" id="report-form">
                <div class="report-form-group">
                    <label class="report-form-label">Issue Type * <span style="font-weight: normal; font-size: 0.85em; opacity: 0.7;">(select all that apply)</span></label>
                    <div class="report-checkbox-group" id="report-category">
                        <label class="report-checkbox-label">
                            <input type="checkbox" name="issue-type" value="wrong-content">
                            <span class="report-checkbox-text">Wrong Content</span>
                        </label>
                        <label class="report-checkbox-label">
                            <input type="checkbox" name="issue-type" value="poor-quality">
                            <span class="report-checkbox-text">Poor Quality</span>
                        </label>
                        <label class="report-checkbox-label">
                            <input type="checkbox" name="issue-type" value="duplicate">
                            <span class="report-checkbox-text">Duplicate</span>
                        </label>
                        <label class="report-checkbox-label">
                            <input type="checkbox" name="issue-type" value="inappropriate">
                            <span class="report-checkbox-text">Inappropriate</span>
                        </label>
                        <label class="report-checkbox-label">
                            <input type="checkbox" name="issue-type" value="weather-mismatch">
                            <span class="report-checkbox-text">Weather Mismatch</span>
                        </label>
                        <label class="report-checkbox-label">
                            <input type="checkbox" name="issue-type" value="time-mismatch">
                            <span class="report-checkbox-text">Time Mismatch</span>
                        </label>
                        <label class="report-checkbox-label">
                            <input type="checkbox" name="issue-type" value="technical-issue">
                            <span class="report-checkbox-text">Technical Issue</span>
                        </label>
                        <label class="report-checkbox-label">
                            <input type="checkbox" name="issue-type" value="other">
                            <span class="report-checkbox-text">Other</span>
                        </label>
                    </div>
                </div>
                
                <div class="report-form-group">
                    <label class="report-form-label" for="report-description">Description (optional)</label>
                    <textarea class="report-form-textarea" id="report-description" placeholder="Please describe the issue in more detail..."></textarea>
                </div>
                
                <input type="hidden" id="report-image-id" value="">
                
                <div class="report-form-actions">
                    <button type="submit" class="report-btn report-btn-submit" id="report-submit">Submit Report</button>
                </div>
            </form>
            
            <div class="report-feedback" id="report-feedback">
                <div class="report-feedback-icon" id="report-feedback-icon">‚úÖ</div>
                <div class="report-feedback-title" id="report-feedback-title">Report Submitted</div>
                <div class="report-feedback-message" id="report-feedback-message">Thank you for your feedback!</div>
            </div>
        </div>
    </div>
    
    <script>
        class AliceDisplay {
            constructor() {
                this.controlFile = 'display-control.json';
                this.pollInterval = 5 * 60 * 1000;  // Poll every 5 minutes
                this.baseRetryInterval = 10 * 1000;  // Base retry interval
                this.maxRetryInterval = 5 * 60 * 1000;  // Max 5 minutes between retries
                this.retryCount = 0;
                this.maxRetries = 10;
                this.lastUpdated = null;
                this.currentData = null;
                this.lastGoodData = null;  // Cache last successful data
                this.activeLayer = 'a';
                this.isDebugMode = new URLSearchParams(window.location.search).has('debug');
                this.isOnline = navigator.onLine;
                this.errorCountdownInterval = null;
                this.usingFallback = false;
                this.isPaused = false;  // For pause/resume functionality
                
                // Fallback image (base64 placeholder or default)
                this.fallbackImageUrl = 'images/generated/morning-sunny.png';
                
                // DOM elements
                this.layerA = document.getElementById('layer-a');
                this.layerB = document.getElementById('layer-b');
                this.titleEl = document.getElementById('title-overlay');
                this.statusEl = document.getElementById('status-overlay');
                this.spinnerEl = document.getElementById('loading-spinner');
                this.errorEl = document.getElementById('error-message');
                this.errorTitleEl = document.getElementById('error-title');
                this.errorDetailEl = document.getElementById('error-detail');
                this.errorCountdownEl = document.getElementById('error-countdown');
                this.debugEl = document.getElementById('debug-panel');
                this.debugContent = document.getElementById('debug-content');
                this.updateIndicator = document.getElementById('update-indicator');
                this.countdownEl = document.getElementById('countdown');
                this.connectionStatusEl = document.getElementById('connection-status');
                this.connectionTextEl = document.getElementById('connection-text');
                this.fallbackBadgeEl = document.getElementById('fallback-badge');
                
                // Weather icons mapping
                this.weatherIcons = {
                    'Sunny': '‚òÄÔ∏è',
                    'Partly Cloudy': '‚õÖ',
                    'Cloudy': '‚òÅÔ∏è',
                    'Overcast': 'üå•Ô∏è',
                    'Rainy': 'üåßÔ∏è',
                    'Stormy': '‚õàÔ∏è',
                    'Snowy': '‚ùÑÔ∏è',
                    'Foggy': 'üå´Ô∏è',
                    'Clear Night': 'üåô',
                    'Windy': 'üí®'
                };
                
                this.init();
            }
            
            async init() {
                if (this.isDebugMode) {
                    this.debugEl.classList.add('show');
                }
                
                this.setupEventListeners();
                this.setupNetworkListeners();
                this.initializeStatusOverlay();
                this.initializeReportModal();
                this.preventMobileScroll();  // Prevent iOS Safari scroll
                this.spinnerEl.classList.add('active');
                await this.loadDisplay(true);  // Initial load
                this.startPolling();
                
                // Show status bar briefly on load
                this.statusEl.classList.add('visible');
                setTimeout(() => {
                    this.statusEl.classList.remove('visible');
                }, 5000);
            }
            
            preventMobileScroll() {
                // Prevent scroll on iOS Safari except in modal content
                document.addEventListener('touchmove', (e) => {
                    const modal = document.getElementById('report-modal');
                    const modalContent = document.querySelector('.report-modal-content');
                    
                    // Allow scroll only inside the report modal content
                    if (modal.classList.contains('show') && modalContent && modalContent.contains(e.target)) {
                        return; // Allow scrolling in modal
                    }
                    
                    // Prevent scroll everywhere else
                    e.preventDefault();
                }, { passive: false });
            }
            
            initializeStatusOverlay() {
                // Start collapsed on mobile portrait to avoid overlap
                const isMobilePortrait = window.innerWidth <= 480 && window.innerHeight > window.innerWidth;
                if (isMobilePortrait) {
                    const statusOverlay = document.getElementById('status-overlay');
                    const displayContainer = document.querySelector('.display-container');
                    
                    statusOverlay.classList.add('collapsed');
                    displayContainer.classList.add('status-collapsed');
                }
            }
            
            handleOrientationChange() {
                const statusOverlay = document.getElementById('status-overlay');
                const displayContainer = document.querySelector('.display-container');
                const landscapeClock = document.getElementById('landscape-clock');
                const portraitClock = document.getElementById('portrait-clock');
                const desktopInfoPanel = document.getElementById('desktop-info-panel');
                
                const isMobilePortrait = window.innerWidth <= 480 && window.innerHeight > window.innerWidth;
                const isMobileLandscape = window.innerHeight <= 480 && window.innerWidth > window.innerHeight;
                const isDesktop = window.innerWidth >= 1200;
                
                if (isMobilePortrait) {
                    // Mobile portrait mode
                    if (!statusOverlay.classList.contains('collapsed')) {
                        statusOverlay.classList.add('collapsed');
                        displayContainer.classList.add('status-collapsed');
                    }
                    // Hide landscape clock, show portrait clock
                    if (landscapeClock) landscapeClock.style.display = 'none';
                    if (portraitClock) portraitClock.style.display = 'flex';
                    // Hide desktop info panel
                    if (desktopInfoPanel) desktopInfoPanel.style.display = 'none';
                    
                } else if (isMobileLandscape) {
                    // Mobile landscape mode
                    statusOverlay.classList.remove('collapsed');
                    displayContainer.classList.remove('status-collapsed');
                    // Show landscape clock, hide portrait clock
                    if (landscapeClock) landscapeClock.style.display = 'flex';
                    if (portraitClock) portraitClock.style.display = 'none';
                    // Hide desktop info panel
                    if (desktopInfoPanel) desktopInfoPanel.style.display = 'none';
                    
                } else if (isDesktop) {
                    // Desktop mode
                    statusOverlay.classList.remove('collapsed');
                    displayContainer.classList.remove('status-collapsed');
                    // Hide both standalone clocks (weather widget has integrated clock)
                    if (landscapeClock) landscapeClock.style.display = 'none';
                    if (portraitClock) portraitClock.style.display = 'none';
                    // Show desktop info panel
                    if (desktopInfoPanel) desktopInfoPanel.style.display = 'block';
                    // Update desktop info
                    this.updateDesktopInfo();
                    
                } else {
                    // Tablet mode
                    statusOverlay.classList.remove('collapsed');
                    displayContainer.classList.remove('status-collapsed');
                    // Hide both standalone clocks (weather widget has integrated clock)
                    if (landscapeClock) landscapeClock.style.display = 'none';
                    if (portraitClock) portraitClock.style.display = 'none';
                    // Hide desktop info panel
                    if (desktopInfoPanel) desktopInfoPanel.style.display = 'none';
                }
            }
            
            updateDesktopInfo() {
                // Update desktop info panel with current data
                if (this.currentData) {
                    const titleEl = document.getElementById('desktop-info-title');
                    const updatedEl = document.getElementById('desktop-info-updated');
                    const timeEl = document.getElementById('desktop-info-time');
                    const activityEl = document.getElementById('desktop-info-activity');
                    const weatherEl = document.getElementById('desktop-info-weather');
                    const screenEl = document.getElementById('desktop-info-screen');
                    
                    if (titleEl) titleEl.textContent = this.currentData.title || '--';
                    if (updatedEl) updatedEl.textContent = this.currentData.updated || '--';
                    if (timeEl) timeEl.textContent = this.currentData.time || '--';
                    if (activityEl) activityEl.textContent = this.currentData.activity || '--';
                    if (weatherEl) weatherEl.textContent = this.currentData.weather || '--';
                    if (screenEl) screenEl.textContent = `${window.innerWidth}√ó${window.innerHeight}`;
                }
            }
            
            setupNetworkListeners() {
                window.addEventListener('online', () => {
                    this.isOnline = true;
                    this.showConnectionStatus('Back online', false);
                    this.retryCount = 0;  // Reset retry count
                    this.loadDisplay(true);  // Immediately try to load
                });
                
                window.addEventListener('offline', () => {
                    this.isOnline = false;
                    this.showConnectionStatus('Offline', true);
                    this.showFallbackImage();
                });
            }
            
            showConnectionStatus(text, isError) {
                this.connectionTextEl.textContent = text;
                this.connectionStatusEl.classList.toggle('error', isError);
                this.connectionStatusEl.classList.add('visible');
                
                // Auto-hide success messages
                if (!isError) {
                    setTimeout(() => {
                        this.connectionStatusEl.classList.remove('visible');
                    }, 3000);
                }
            }
            
            showFallbackImage() {
                if (this.lastGoodData) {
                    // Show last known good image
                    this.updateDisplay(this.lastGoodData, true);
                    this.usingFallback = true;
                    this.fallbackBadgeEl.classList.add('show');
                    document.body.classList.add('fallback-active');
                } else if (this.fallbackImageUrl) {
                    // Show default fallback
                    this.crossfadeImage(this.fallbackImageUrl, 'Alice (Fallback)', true);
                    this.usingFallback = true;
                    this.fallbackBadgeEl.classList.add('show');
                    document.body.classList.add('fallback-active');
                }
            }
            
            clearFallbackState() {
                this.usingFallback = false;
                this.fallbackBadgeEl.classList.remove('show');
                document.body.classList.remove('fallback-active');
                this.connectionStatusEl.classList.remove('visible');
            }
            
            setupEventListeners() {
                // Fullscreen button
                document.getElementById('fullscreen-btn').addEventListener('click', () => {
                    this.toggleFullscreen();
                });
                
                // Status overlay click to toggle
                document.getElementById('status-overlay').addEventListener('click', () => {
                    this.toggleStatusOverlay();
                });
                
                // Weather widget click to toggle visibility
                document.getElementById('weather-widget').addEventListener('click', () => {
                    this.toggleWeatherWidget();
                });
                
                // Show status on mouse move / touch
                let hideTimeout;
                const showOverlays = () => {
                    this.statusEl.classList.add('visible');
                    this.titleEl.classList.add('visible');
                    this.countdownEl.classList.add('visible');
                    clearTimeout(hideTimeout);
                    hideTimeout = setTimeout(() => {
                        this.statusEl.classList.remove('visible');
                        this.titleEl.classList.remove('visible');
                        this.countdownEl.classList.remove('visible');
                    }, 4000);
                };
                document.addEventListener('mousemove', showOverlays);
                document.addEventListener('touchstart', showOverlays);
                
                // Tap-to-copy: tapping the activity area copies the current image's
                // Cloudinary URL to the clipboard. Shows a brief green toast confirmation.
                document.getElementById('activity-item').addEventListener('click', (e) => {
                    e.stopPropagation();  // Don't trigger the show/hide overlays
                    
                    // Get the current image URL from the last loaded data
                    const url = this.currentData?.currentImage?.url;
                    if (!url) {
                        this.showCopyToast('‚ö†Ô∏è No image URL');
                        return;
                    }
                    
                    // Copy to clipboard using the modern API with fallback
                    if (navigator.clipboard && navigator.clipboard.writeText) {
                        navigator.clipboard.writeText(url).then(() => {
                            this.showCopyToast('üìã Link copied!');
                        }).catch(() => {
                            this.fallbackCopy(url);
                        });
                    } else {
                        this.fallbackCopy(url);
                    }
                });
                
                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Ignore if typing in an input
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    
                    switch(e.key.toLowerCase()) {
                        case 'd':
                            if (e.ctrlKey) {
                                e.preventDefault();
                                this.debugEl.classList.toggle('show');
                            }
                            break;
                        case 'r':
                            if (e.shiftKey) {
                                // Shift+R for report modal
                                e.preventDefault();
                                this.showReportModal();
                            } else if (!e.ctrlKey) {
                                // R for refresh
                                e.preventDefault();
                                this.loadDisplay(true);
                                this.showToast('üîÑ Refreshing...');
                            }
                            break;
                        case 'f':
                            e.preventDefault();
                            this.toggleFullscreen();
                            break;
                        case 's':
                            e.preventDefault();
                            this.statusEl.classList.toggle('visible');
                            this.titleEl.classList.toggle('visible');
                            break;
                        case 'w':
                            e.preventDefault();
                            this.toggleStatusOverlay();
                            break;
                        case ' ':
                            e.preventDefault();
                            this.togglePause();
                            break;
                        case 'h':
                        case '?':
                            e.preventDefault();
                            this.toggleHelp();
                            break;
                        case 'i':
                            e.preventDefault();
                            this.showImageInfo();
                            break;
                        case 'escape':
                            this.closeAllPanels();
                            break;
                        case 'c':
                            // Copy current image URL to clipboard
                            if (!e.ctrlKey && !e.metaKey) {
                                e.preventDefault();
                                const copyUrl = this.currentData?.currentImage?.url;
                                if (copyUrl) {
                                    navigator.clipboard?.writeText(copyUrl).then(() => {
                                        this.showCopyToast('üìã Link copied!');
                                    }).catch(() => this.fallbackCopy(copyUrl));
                                }
                            }
                            break;
                        case 'arrowleft':
                            e.preventDefault();
                            this.showToast('‚èÆÔ∏è Previous (not implemented)');
                            break;
                        case 'arrowright':
                            e.preventDefault();
                            this.showToast('‚è≠Ô∏è Next (not implemented)');
                            break;
                    }
                });
                
                // Check for updates when page becomes visible again
                document.addEventListener('visibilitychange', () => {
                    if (!document.hidden) {
                        this.loadDisplay();
                    }
                });
                
                // Handle orientation changes for weather widget positioning
                window.addEventListener('orientationchange', () => {
                    // Delay to allow orientation change to complete
                    setTimeout(() => {
                        this.handleOrientationChange();
                    }, 100);
                });
                
                // Also handle window resize for responsive behavior
                window.addEventListener('resize', () => {
                    this.handleOrientationChange();
                });
            }
            
            async loadDisplay(forceUpdate = false) {
                // Check if offline
                if (!navigator.onLine) {
                    this.handleError('offline', 'You appear to be offline');
                    return;
                }
                
                try {
                    const controller = new AbortController();
                    const timeout = setTimeout(() => controller.abort(), 15000);  // 15s timeout
                    
                    const response = await fetch(`${this.controlFile}?t=${Date.now()}`, {
                        signal: controller.signal
                    });
                    clearTimeout(timeout);
                    
                    if (!response.ok) {
                        throw new Error(`Server returned ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    // Validate data structure
                    if (!data || !data.currentImage) {
                        throw new Error('Invalid data format');
                    }
                    
                    // Success! Reset error state
                    this.retryCount = 0;
                    this.clearError();
                    this.clearFallbackState();
                    
                    // Check if data has changed
                    const newLastUpdated = data.lastUpdated;
                    const hasChanged = forceUpdate || (newLastUpdated !== this.lastUpdated);
                    
                    if (hasChanged && newLastUpdated) {
                        console.log('ü¶ú Update detected:', newLastUpdated);
                        this.lastUpdated = newLastUpdated;
                        this.currentData = data;
                        this.lastGoodData = data;  // Cache for fallback
                        await this.updateDisplay(data, !forceUpdate);
                        this.updateDebug(data);
                        this.updateWeatherWidget();
                        this.startWidgetClock();
                        
                        // Update about panel if it's open
                        if (document.getElementById('about-panel').classList.contains('show')) {
                            this.updateAboutInfo();
                        }
                        
                        // Show update indicator (not on initial load)
                        if (!forceUpdate && this.lastUpdated) {
                            this.showUpdateIndicator();
                        }
                    } else {
                        this.updateDebug({ ...data, _status: 'No changes detected' });
                    }
                    
                } catch (error) {
                    console.error('Error loading display:', error);
                    
                    // Categorize the error
                    let errorType = 'unknown';
                    let errorMessage = error.message;
                    
                    if (error.name === 'AbortError') {
                        errorType = 'timeout';
                        errorMessage = 'Request timed out';
                    } else if (error.message.includes('Failed to fetch')) {
                        errorType = 'network';
                        errorMessage = 'Network connection failed';
                    } else if (error.message.includes('Server returned')) {
                        errorType = 'server';
                    } else if (error.message.includes('Invalid data')) {
                        errorType = 'data';
                        errorMessage = 'Received invalid data';
                    }
                    
                    this.handleError(errorType, errorMessage);
                }
            }
            
            handleError(type, message) {
                // Cap the retry counter at maxRetries to prevent runaway display
                if (this.retryCount <= this.maxRetries) {
                    this.retryCount++;
                }
                this.updateDebug({ error: message, type, retryCount: Math.min(this.retryCount, this.maxRetries) });
                
                // Calculate retry interval with exponential backoff
                const retryInterval = Math.min(
                    this.baseRetryInterval * Math.pow(1.5, this.retryCount - 1),
                    this.maxRetryInterval
                );
                
                // Set error message based on type
                const errorMessages = {
                    offline: { title: 'You\'re Offline', icon: 'üì°' },
                    timeout: { title: 'Connection Slow', icon: '‚è±Ô∏è' },
                    network: { title: 'Connection Failed', icon: 'üîå' },
                    server: { title: 'Server Issue', icon: 'üñ•Ô∏è' },
                    data: { title: 'Data Error', icon: '‚ö†Ô∏è' },
                    image: { title: 'Image Load Failed', icon: 'üñºÔ∏è' },
                    unknown: { title: 'Something Went Wrong', icon: 'ü¶ú' }
                };
                
                const errorInfo = errorMessages[type] || errorMessages.unknown;
                
                // Show fallback if we have one and this isn't the first load
                if (this.lastGoodData || this.currentData) {
                    this.showFallbackImage();
                }
                
                // Show error UI
                this.showError(errorInfo.title, message, retryInterval);
                
                // Schedule retry (unless we've exceeded max retries)
                if (this.retryCount <= this.maxRetries) {
                    setTimeout(() => this.loadDisplay(), retryInterval);
                } else {
                    this.errorDetailEl.textContent = 'Max retries exceeded. Tap to retry.';
                    this.errorEl.onclick = () => {
                        this.retryCount = 0;
                        this.loadDisplay(true);
                    };
                }
            }
            
            showError(title = 'Connection Issue', detail = 'Unable to load display', retryIn = 10000) {
                this.spinnerEl.classList.remove('active');
                this.errorTitleEl.textContent = title;
                this.errorDetailEl.textContent = detail;
                this.errorEl.classList.add('show');
                
                // Update retry counter inside modal (capped at maxRetries)
                const retryCounterEl = document.getElementById('error-retry-counter');
                if (retryCounterEl) {
                    const displayCount = Math.min(this.retryCount, this.maxRetries);
                    retryCounterEl.textContent = `Retry ${displayCount}/${this.maxRetries}`;
                }
                
                // Hide connection status when error modal is shown
                this.connectionStatusEl.classList.remove('show');
                
                // Update countdown
                if (this.errorCountdownInterval) {
                    clearInterval(this.errorCountdownInterval);
                }
                
                let remaining = Math.ceil(retryIn / 1000);
                this.errorCountdownEl.textContent = remaining;
                
                this.errorCountdownInterval = setInterval(() => {
                    remaining--;
                    if (remaining > 0) {
                        this.errorCountdownEl.textContent = remaining;
                    } else {
                        clearInterval(this.errorCountdownInterval);
                    }
                }, 1000);
            }
            
            clearError() {
                this.errorEl.classList.remove('show');
                this.errorEl.onclick = null;
                if (this.errorCountdownInterval) {
                    clearInterval(this.errorCountdownInterval);
                }
            }
            
            async updateDisplay(data, animate = true) {
                const { currentImage, weather, time } = data;
                
                // Update image with crossfade
                if (currentImage && currentImage.url) {
                    await this.crossfadeImage(currentImage.url, currentImage.title, animate);
                }
                
                // Update title
                if (currentImage && currentImage.title) {
                    this.titleEl.textContent = currentImage.title;
                }
                
                // Update weather
                if (weather) {
                    document.getElementById('weather-icon').textContent = 
                        this.weatherIcons[weather.condition] || 'üå°Ô∏è';
                    document.getElementById('weather-condition').textContent = 
                        weather.condition || 'Unknown';
                    document.getElementById('temperature').textContent = 
                        weather.temperature ? `${Math.round(weather.temperature)}¬∞C` : '';
                }
                
                // Update time
                if (time) {
                    document.getElementById('time-period').textContent = 
                        time.period || 'Unknown';
                    const now = new Date();
                    document.getElementById('current-time').textContent = 
                        now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: false });
                }
                
                // Update activity
                if (currentImage && currentImage.activity) {
                    document.getElementById('activity').textContent = currentImage.activity;
                }
                
                this.spinnerEl.classList.remove('active');
            }
            
            crossfadeImage(url, title, animate = true) {
                return new Promise((resolve) => {
                    // Determine which layer to load into
                    const nextLayer = this.activeLayer === 'a' ? 'b' : 'a';
                    const nextLayerEl = nextLayer === 'a' ? this.layerA : this.layerB;
                    const currentLayerEl = this.activeLayer === 'a' ? this.layerA : this.layerB;
                    const nextImg = nextLayerEl.querySelector('img');
                    
                    // Preload the image with timeout
                    const preloader = new Image();
                    const loadTimeout = setTimeout(() => {
                        console.warn('Image load timeout:', url);
                        this.handleImageError(url, 'timeout');
                        resolve();
                    }, 30000);  // 30s timeout for image load
                    
                    preloader.onload = () => {
                        clearTimeout(loadTimeout);
                        nextImg.src = url;
                        nextImg.alt = title || 'Alice';
                        
                        // Apply random Ken Burns effect
                        const kbVariants = ['kenburns-1', 'kenburns-2', 'kenburns-3', 'kenburns-4'];
                        const randomKB = kbVariants[Math.floor(Math.random() * kbVariants.length)];
                        
                        // Remove old Ken Burns classes and add new one
                        nextImg.classList.remove('kenburns', 'kenburns-1', 'kenburns-2', 'kenburns-3', 'kenburns-4');
                        nextImg.classList.add('kenburns', randomKB);
                        
                        // Also remove from the old layer's image to reset it
                        const currentImg = currentLayerEl.querySelector('img');
                        currentImg.classList.remove('kenburns', 'kenburns-1', 'kenburns-2', 'kenburns-3', 'kenburns-4');
                        
                        // Crossfade: show new layer, hide old
                        nextLayerEl.classList.remove('inactive');
                        nextLayerEl.classList.add('active');
                        currentLayerEl.classList.remove('active');
                        currentLayerEl.classList.add('inactive');
                        
                        this.activeLayer = nextLayer;
                        this.spinnerEl.classList.remove('active');
                        resolve();
                    };
                    
                    preloader.onerror = () => {
                        clearTimeout(loadTimeout);
                        console.error('Failed to load image:', url);
                        this.handleImageError(url, 'load');
                        resolve();
                    };
                    
                    preloader.src = url;
                });
            }
            
            handleImageError(url, reason) {
                console.warn(`Image error (${reason}):`, url);
                
                // Try fallback image if main image fails
                if (!this.usingFallback && url !== this.fallbackImageUrl) {
                    console.log('Attempting fallback image...');
                    this.usingFallback = true;
                    this.fallbackBadgeEl.textContent = '‚ö†Ô∏è Image unavailable';
                    this.fallbackBadgeEl.classList.add('show');
                    
                    // Try fallback
                    if (this.lastGoodData && this.lastGoodData.currentImage) {
                        this.crossfadeImage(
                            this.lastGoodData.currentImage.url,
                            this.lastGoodData.currentImage.title + ' (cached)',
                            true
                        );
                    } else {
                        this.crossfadeImage(this.fallbackImageUrl, 'Alice (Fallback)', true);
                    }
                } else {
                    // Even fallback failed - show error state
                    this.handleError('image', 'Unable to load images');
                }
            }
            
            showUpdateIndicator() {
                this.updateIndicator.classList.add('show');
                setTimeout(() => {
                    this.updateIndicator.classList.remove('show');
                }, 3000);
            }
            
            updateDebug(data) {
                if (!this.isDebugMode) return;
                const debugInfo = {
                    ...data,
                    _pollInterval: `${this.pollInterval / 1000}s`,
                    _lastChecked: new Date().toISOString()
                };
                this.debugContent.textContent = JSON.stringify(debugInfo, null, 2);
            }
            
            toggleFullscreen() {
                if (!document.fullscreenElement) {
                    document.documentElement.requestFullscreen().catch(err => {
                        console.log('Fullscreen error:', err);
                    });
                    this.showToast('üñ•Ô∏è Fullscreen');
                } else {
                    document.exitFullscreen();
                    this.showToast('ü™ü Windowed');
                }
            }
            
            /**
             * Show the green "Link copied!" toast above the status bar.
             * Auto-hides after 1.5 seconds.
             */
            showCopyToast(message) {
                const toast = document.getElementById('copy-toast');
                toast.textContent = message;
                toast.classList.add('show');
                clearTimeout(this._copyToastTimer);
                this._copyToastTimer = setTimeout(() => {
                    toast.classList.remove('show');
                }, 1500);
            }
            
            /**
             * Fallback for copying text on older browsers / non-HTTPS contexts.
             * Creates a temporary textarea, selects the text, and uses execCommand.
             */
            fallbackCopy(text) {
                // Use a hidden textarea to copy text to clipboard.
                // We set readOnly and move the textarea offscreen to prevent
                // the iOS keyboard from appearing when we call select().
                const textarea = document.createElement('textarea');
                textarea.value = text;
                textarea.setAttribute('readonly', '');  // Prevent keyboard on iOS
                textarea.style.position = 'fixed';
                textarea.style.left = '-9999px';  // Move offscreen
                textarea.style.top = '-9999px';
                textarea.style.opacity = '0';
                document.body.appendChild(textarea);
                textarea.select();
                try {
                    document.execCommand('copy');
                    this.showCopyToast('üìã Link copied!');
                } catch (err) {
                    this.showCopyToast('‚ö†Ô∏è Copy failed');
                }
                document.body.removeChild(textarea);
            }
            
            togglePause() {
                this.isPaused = !this.isPaused;
                const pauseIndicator = document.getElementById('pause-indicator');
                if (this.isPaused) {
                    pauseIndicator.classList.add('show');
                    this.showToast('‚è∏Ô∏è Paused');
                } else {
                    pauseIndicator.classList.remove('show');
                    this.showToast('‚ñ∂Ô∏è Resumed');
                    this.loadDisplay();  // Refresh immediately when unpausing
                }
            }
            
            toggleHelp() {
                const helpOverlay = document.getElementById('help-overlay');
                helpOverlay.classList.toggle('show');
            }
            
            toggleStatusOverlay() {
                const statusOverlay = document.getElementById('status-overlay');
                const displayContainer = document.querySelector('.display-container');
                
                // Toggle between expanded and collapsed states
                statusOverlay.classList.toggle('collapsed');
                
                // Update display container class for image spacing
                displayContainer.classList.toggle('status-collapsed', statusOverlay.classList.contains('collapsed'));
                
                if (statusOverlay.classList.contains('collapsed')) {
                    this.showToast('üìç Status minimized');
                } else {
                    this.showToast('üìç Status expanded');
                }
            }
            
            toggleWeatherWidget() {
                const weatherWidget = document.getElementById('weather-widget');
                const displayContainer = document.querySelector('.display-container');
                
                // Toggle visibility
                weatherWidget.classList.toggle('hidden');
                
                // Update display container class for image spacing
                displayContainer.classList.toggle('widget-hidden', weatherWidget.classList.contains('hidden'));
                
                if (weatherWidget.classList.contains('hidden')) {
                    this.showToast('üå§Ô∏è Tap icon to expand');
                } else {
                    this.showToast('üå§Ô∏è Tap to collapse');
                }
            }
            
            updateWeatherWidget() {
                if (!this.currentData) return;
                
                const data = this.currentData;
                document.getElementById('widget-weather-icon').textContent = 
                    this.weatherIcons[data.weather?.condition] || 'üå°Ô∏è';
                document.getElementById('widget-temp').textContent = 
                    data.weather?.temperature ?? '--';
                document.getElementById('widget-condition').textContent = 
                    data.weather?.condition || 'Unknown';
                document.getElementById('widget-description').textContent = 
                    data.weather?.description || '';
                document.getElementById('widget-humidity').textContent = 
                    (data.weather?.humidity ?? '--') + '%';
                const periodText = data.time?.period || '--';
                document.getElementById('widget-period').textContent = periodText;
                // Also update the portrait standalone clock period
                const portraitPeriod = document.getElementById('portrait-clock-period');
                if (portraitPeriod) portraitPeriod.textContent = periodText;
                
                document.getElementById('widget-activity').textContent = 
                    data.currentImage?.activity || data.activity || '--';
            }
            
            startWidgetClock() {
                // Update both the widget clock and the portrait standalone clock
                const updateClock = () => {
                    const now = new Date();
                    const timeStr = now.toLocaleTimeString('en-US', { 
                        hour: '2-digit', 
                        minute: '2-digit',
                        hour12: false,
                        timeZone: 'Asia/Hebron'
                    });
                    const period = now.getHours() < 12 ? 'AM' : 'PM';
                    
                    // Update the in-widget clock (visible on desktop/landscape)
                    document.getElementById('widget-clock').textContent = timeStr;
                    
                    // Update the portrait standalone clock (visible on mobile portrait)
                    const portraitClock = document.getElementById('portrait-clock-time');
                    if (portraitClock) portraitClock.textContent = timeStr;
                    
                    // Update the landscape standalone clock (visible on mobile landscape)
                    const landscapeClock = document.getElementById('landscape-clock-time');
                    const landscapePeriod = document.getElementById('landscape-clock-period');
                    if (landscapeClock) landscapeClock.textContent = timeStr;
                    if (landscapePeriod) landscapePeriod.textContent = period;
                };
                updateClock();
                
                // Only set interval if not already running
                if (!this.clockInterval) {
                    this.clockInterval = setInterval(updateClock, 1000);
                }
            }
            
            showImageInfo() {
                const infoPanel = document.getElementById('image-info');
                if (this.currentData) {
                    document.getElementById('info-title').textContent = this.currentData.title || '--';
                    document.getElementById('info-weather').textContent = this.currentData.weather || '--';
                    document.getElementById('info-time').textContent = this.currentData.time || '--';
                    document.getElementById('info-activity').textContent = this.currentData.activity || '--';
                    document.getElementById('info-updated').textContent = this.currentData.updated || '--';
                }
                infoPanel.classList.toggle('show');
            }
            
            initializeCommandCenter() {
                const commandCenter = document.getElementById('command-center');
                const commandButton = document.getElementById('command-center-button');
                const backdrop = document.getElementById('command-center-backdrop');
                const cmdVacuum = document.getElementById('cmd-vacuum');
                const cmdLights = document.getElementById('cmd-lights');
                const cmdImage = document.getElementById('cmd-image');
                const cmdAbout = document.getElementById('cmd-about');
                
                // Toggle Command Center popup
                commandButton.addEventListener('click', () => {
                    commandCenter.classList.toggle('open');
                });
                
                // Close on backdrop tap
                backdrop.addEventListener('click', () => {
                    commandCenter.classList.remove('open');
                });
                
                // Vacuum button ‚Üí show vacuum panel
                cmdVacuum.addEventListener('click', (e) => {
                    e.stopPropagation();
                    console.log('ü§ñ Vacuum clicked');
                    commandCenter.classList.remove('open');
                    this.showVacuumPanel();
                });
                
                // Lights button ‚Üí show lights panel
                cmdLights.addEventListener('click', (e) => {
                    e.stopPropagation();
                    console.log('üí° Lights clicked');
                    commandCenter.classList.remove('open');
                    this.showLightsPanel();
                });
                
                // Image button ‚Üí show image control panel
                cmdImage.addEventListener('click', (e) => {
                    e.stopPropagation();
                    console.log('üñºÔ∏è Image clicked');
                    commandCenter.classList.remove('open');
                    this.showImageControlPanel();
                });
                
                // About button ‚Üí show about panel
                cmdAbout.addEventListener('click', (e) => {
                    e.stopPropagation();
                    console.log('‚ÑπÔ∏è About clicked');
                    commandCenter.classList.remove('open');
                    this.showAboutPanel();
                });
                
                // Close on Escape key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && commandCenter.classList.contains('open')) {
                        commandCenter.classList.remove('open');
                    }
                });
            }
            
            initializeReportModal() {
                const reportModal = document.getElementById('report-modal');
                const reportClose = document.getElementById('report-modal-close');
                const reportForm = document.getElementById('report-form');
                
                // Initialize Command Center (which includes report button)
                this.initializeCommandCenter();
                
                // Initialize Vacuum Panel
                this.initializeVacuumPanel();
                
                // Initialize Lights Panel
                this.initializeLightsPanel();
                
                // Initialize Image Control Panel
                this.initializeImageControlPanel();
                
                // Initialize About Panel
                this.initializeAboutPanel();
                
                // Close modal when close button clicked
                reportClose.addEventListener('click', () => {
                    this.hideReportModal();
                });
                
                // Close modal when clicking outside
                reportModal.addEventListener('click', (e) => {
                    if (e.target === reportModal) {
                        this.hideReportModal();
                    }
                });
                
                // Handle form submission
                reportForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.submitReport();
                });
                
                // Close modal with Escape key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && reportModal.classList.contains('show')) {
                        this.hideReportModal();
                    }
                });
            }
            
            showReportModal() {
                const modal = document.getElementById('report-modal');
                const form = document.getElementById('report-form');
                const feedback = document.getElementById('report-feedback');
                
                // Reset form
                form.reset();
                form.style.display = 'flex';
                feedback.style.display = 'none';
                
                // Populate current image info if available
                if (this.currentData && this.currentData.currentImage) {
                    document.getElementById('report-image-id').value = this.currentData.currentImage.notion_id || this.currentData.currentImage.id || '';
                }
                
                // Lock body scroll when modal is open
                document.body.style.overflow = 'hidden';
                document.body.style.position = 'fixed';
                document.body.style.width = '100%';
                
                modal.classList.add('show');
                
                // Focus on category select
                setTimeout(() => {
                    document.getElementById('report-category').focus();
                }, 100);
            }
            
            hideReportModal() {
                const modal = document.getElementById('report-modal');
                modal.classList.remove('show');
                
                // Restore body scroll
                document.body.style.overflow = '';
                document.body.style.position = '';
                document.body.style.width = '';
            }
            
            async submitReport() {
                const submitButton = document.getElementById('report-submit');
                const checkboxes = document.querySelectorAll('input[name="issue-type"]:checked');
                const selectedCategories = Array.from(checkboxes).map(cb => cb.value);
                const description = document.getElementById('report-description').value;
                const imageId = document.getElementById('report-image-id').value;
                
                if (selectedCategories.length === 0) {
                    this.showToast('‚ö†Ô∏è Please select at least one issue type');
                    return;
                }
                
                // Disable submit button
                submitButton.disabled = true;
                submitButton.textContent = 'Submitting...';
                
                try {
                    // Gather context data for the report
                    const reportData = {
                        image_data: {
                            notion_id: imageId,
                            title: this.currentData?.currentImage?.title || '',
                            url: this.currentData?.currentImage?.url || '',
                            style: this.currentData?.currentImage?.style || '',
                            row_number: this.currentData?.currentImage?.row_number || 0
                        },
                        categories: selectedCategories,
                        notes: description,
                        context_data: {
                            time_of_day: this.currentData?.time?.period || '',
                            weather_shown: this.currentData?.weather?.condition || '',
                            actual_weather: this.currentData?.weather?.condition || '',
                            weather_mismatch: false, // Would need more logic to detect this
                            hebrew_date: '', // Would need Hebrew calendar integration
                            sunrise: '',
                            sunset: '',
                            holiday: null,
                            user_agent: navigator.userAgent,
                            screen_resolution: `${screen.width}x${screen.height}`,
                            platform: navigator.platform
                        }
                    };
                    
                    // Try to submit to server endpoint
                    let success = await this.submitReportToServer(reportData);
                    
                    // Fallback to localStorage if server fails
                    if (!success) {
                        success = this.submitReportToLocalStorage(reportData);
                    }
                    
                    this.showReportFeedback(success);
                    
                } catch (error) {
                    console.error('Error submitting report:', error);
                    // Fallback to localStorage
                    const success = this.submitReportToLocalStorage({
                        category,
                        description,
                        imageId,
                        timestamp: new Date().toISOString(),
                        imageTitle: this.currentData?.currentImage?.title || ''
                    });
                    this.showReportFeedback(success);
                } finally {
                    // Re-enable submit button
                    submitButton.disabled = false;
                    submitButton.textContent = 'Submit Report';
                }
            }
            
            async submitReportToServer(reportData) {
                // Production API endpoint for image reports (deployed on Vercel)
                const API_ENDPOINT = 'https://alice-report-api.vercel.app/api/report';
                
                try {
                    console.log('Submitting report to API:', API_ENDPOINT);
                    console.log('Report data:', reportData);
                    
                    const response = await fetch(API_ENDPOINT, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(reportData)
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        console.log('Report submitted to server successfully:', result);
                        return true;
                    } else {
                        console.warn('Server report submission failed:', response.status);
                        const errorText = await response.text();
                        console.warn('Error details:', errorText);
                        return false;
                    }
                } catch (error) {
                    console.warn('Network error submitting report:', error);
                    return false;
                }
            }
            
            submitReportToLocalStorage(reportData) {
                try {
                    const reportId = 'RPT-' + Date.now() + '-' + Math.random().toString(36).substr(2, 6).toUpperCase();
                    const report = {
                        id: reportId,
                        ...reportData,
                        timestamp: new Date().toISOString()
                    };
                    
                    // Get existing reports
                    const existingReports = JSON.parse(localStorage.getItem('aliceDisplayReports') || '[]');
                    existingReports.push(report);
                    
                    // Keep only last 50 reports to avoid storage bloat
                    if (existingReports.length > 50) {
                        existingReports.splice(0, existingReports.length - 50);
                    }
                    
                    localStorage.setItem('aliceDisplayReports', JSON.stringify(existingReports));
                    console.log('Report saved to localStorage:', reportId);
                    return true;
                } catch (error) {
                    console.error('Error saving report to localStorage:', error);
                    return false;
                }
            }
            
            showReportFeedback(success) {
                const form = document.getElementById('report-form');
                const feedback = document.getElementById('report-feedback');
                const icon = document.getElementById('report-feedback-icon');
                const title = document.getElementById('report-feedback-title');
                const message = document.getElementById('report-feedback-message');
                
                form.style.display = 'none';
                feedback.style.display = 'block';
                
                if (success) {
                    icon.textContent = '‚úÖ';
                    title.textContent = 'Report Submitted';
                    message.textContent = 'Thank you for your feedback! We\'ll review this issue.';
                } else {
                    icon.textContent = '‚ùå';
                    title.textContent = 'Submission Failed';
                    message.textContent = 'Unable to submit report. Please try again later.';
                }
                
                // Auto-close modal after 3 seconds
                setTimeout(() => {
                    this.hideReportModal();
                }, 3000);
            }
            
            initializeVacuumPanel() {
                const vacuumPanel = document.getElementById('vacuum-panel');
                const vacuumClose = document.getElementById('vacuum-panel-close');
                const vacuumBtnStart = document.getElementById('vacuum-btn-start');
                const vacuumBtnStop = document.getElementById('vacuum-btn-stop');
                const vacuumBtnHome = document.getElementById('vacuum-btn-home');
                
                // Close panel when close button clicked
                vacuumClose.addEventListener('click', () => {
                    this.hideVacuumPanel();
                });
                
                // Close panel when clicking outside
                vacuumPanel.addEventListener('click', (e) => {
                    if (e.target === vacuumPanel) {
                        this.hideVacuumPanel();
                    }
                });
                
                // Vacuum control buttons
                vacuumBtnStart.addEventListener('click', () => this.vacuumStart());
                vacuumBtnStop.addEventListener('click', () => this.vacuumStop());
                vacuumBtnHome.addEventListener('click', () => this.vacuumGoHome());
                
                // Tap battery display to refresh
                const vacuumBattery = document.getElementById('vacuum-battery');
                vacuumBattery.style.cursor = 'pointer';
                vacuumBattery.addEventListener('click', () => {
                    this.showToast('üîÑ Refreshing battery...');
                    this.loadVacuumStatus();
                });
                
                // Close panel with Escape key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && vacuumPanel.classList.contains('show')) {
                        this.hideVacuumPanel();
                    }
                });
            }
            
            async showVacuumPanel() {
                const panel = document.getElementById('vacuum-panel');
                
                // Lock body scroll when panel is open
                document.body.style.overflow = 'hidden';
                document.body.style.position = 'fixed';
                document.body.style.width = '100%';
                
                panel.classList.add('show');
                
                // Load battery status when panel opens
                await this.loadVacuumStatus();
            }
            
            hideVacuumPanel() {
                const panel = document.getElementById('vacuum-panel');
                panel.classList.remove('show');
                
                // Restore body scroll
                document.body.style.overflow = '';
                document.body.style.position = '';
                document.body.style.width = '';
            }
            
            async loadVacuumStatus() {
                const batteryIcon = document.getElementById('vacuum-battery-icon');
                const batteryText = document.getElementById('vacuum-battery-text');
                
                // Show loading state
                batteryIcon.textContent = '‚è≥';
                batteryText.textContent = 'Loading...';
                
                try {
                    // First, try the local API server
                    const apiUrl = 'https://alice-vacuum-api.vercel.app';
                    const response = await fetch(`${apiUrl}/api/vacuum?action=status`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ device: 1 }),
                        signal: AbortSignal.timeout(15000)  // 15 second timeout (Ecovacs API is slow)
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        const isCharging = data.chargeState === 'charging' || data.charging;
                        this.updateVacuumBattery(data.battery, isCharging);
                        this.updateVacuumStatus(data.cleanState || data.clean_status, isCharging);
                        return;
                    } else {
                        throw new Error(`HTTP ${response.status}`);
                    }
                } catch (error) {
                    console.warn('API server not available, trying direct execution:', error.message);
                    
                    // Fallback: Try executing the command directly via browser (if possible)
                    // This won't work in a browser context, so we'll show a helpful message
                    batteryIcon.textContent = 'ü§ñ';
                    batteryText.textContent = 'Yiko Ready';
                    this.updateVacuumStatus('unknown', false);
                    
                    // Show a note about starting the API server
                    this.showToast('üí° Tip: Start vacuum API server for full functionality');
                }
            }
            
            updateVacuumBattery(batteryLevel, isCharging = false) {
                const batteryIcon = document.getElementById('vacuum-battery-icon');
                const batteryText = document.getElementById('vacuum-battery-text');
                
                // Determine battery icon based on level and charging state
                if (isCharging) {
                    batteryIcon.textContent = 'üîå';
                    batteryText.textContent = `${batteryLevel}% (Charging)`;
                } else if (batteryLevel >= 80) {
                    batteryIcon.textContent = 'üîã';
                    batteryText.textContent = `${batteryLevel}% (Full)`;
                } else if (batteryLevel >= 50) {
                    batteryIcon.textContent = 'üîã';
                    batteryText.textContent = `${batteryLevel}% (Good)`;
                } else if (batteryLevel >= 20) {
                    batteryIcon.textContent = 'ü™´';
                    batteryText.textContent = `${batteryLevel}% (Low)`;
                } else {
                    batteryIcon.textContent = 'ü™´';
                    batteryText.textContent = `${batteryLevel}% (Very Low)`;
                }
            }
            
            updateVacuumStatus(cleanStatus, isCharging = false) {
                const statusDiv = document.getElementById('vacuum-status');
                const statusIcon = document.getElementById('vacuum-status-icon');
                const statusText = document.getElementById('vacuum-status-text');
                
                // Remove previous status classes
                statusDiv.classList.remove('cleaning', 'charging', 'idle');
                
                // Determine status display
                if (isCharging) {
                    statusIcon.textContent = 'üîå';
                    statusText.textContent = 'Charging';
                    statusDiv.classList.add('charging');
                } else if (cleanStatus === 'cleaning' || cleanStatus === 'working') {
                    statusIcon.textContent = 'üßπ';
                    statusText.textContent = 'Cleaning';
                    statusDiv.classList.add('cleaning');
                } else if (cleanStatus === 'idle' || cleanStatus === 'stop' || cleanStatus === 'auto') {
                    statusIcon.textContent = '‚úÖ';
                    statusText.textContent = 'Ready';
                    statusDiv.classList.add('idle');
                } else if (cleanStatus === 'paused') {
                    statusIcon.textContent = '‚è∏Ô∏è';
                    statusText.textContent = 'Paused';
                    statusDiv.classList.add('idle');
                } else if (cleanStatus === 'returning') {
                    statusIcon.textContent = 'üè†';
                    statusText.textContent = 'Returning Home';
                    statusDiv.classList.add('charging');
                } else if (cleanStatus === 'unknown') {
                    statusIcon.textContent = '‚ùì';
                    statusText.textContent = 'Unknown';
                } else {
                    statusIcon.textContent = 'üìç';
                    statusText.textContent = cleanStatus || 'Unknown';
                }
            }
            
            async vacuumStart() {
                await this.executeVacuumCommand('clean', 'Starting vacuum...', '‚úÖ Vacuum started!');
            }
            
            async vacuumStop() {
                await this.executeVacuumCommand('stop', 'Stopping vacuum...', '‚èπÔ∏è Vacuum stopped');
            }
            
            async vacuumGoHome() {
                await this.executeVacuumCommand('charge', 'Sending home...', 'üè† Going home');
            }
            
            async executeVacuumCommand(command, loadingMessage, successMessage) {
                const buttons = document.querySelectorAll('.vacuum-btn');
                const clickedBtn = document.querySelector(`.vacuum-btn-${command === 'clean' ? 'start' : command === 'charge' ? 'home' : 'stop'}`);
                
                // Disable all buttons and add loading state to clicked button
                buttons.forEach(btn => {
                    btn.disabled = true;
                });
                
                if (clickedBtn) {
                    clickedBtn.classList.add('loading');
                    const btnText = clickedBtn.querySelector('span:last-child');
                    if (btnText) btnText.textContent = 'Working...';
                }
                
                this.showToast(`‚è≥ ${loadingMessage}`);
                
                try {
                    // Use Vercel-hosted vacuum API
                    const apiUrl = 'https://alice-vacuum-api.vercel.app';
                    const response = await fetch(`${apiUrl}/api/vacuum?action=${command}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            device: 1,
                            command: command
                        }),
                        signal: AbortSignal.timeout(30000)  // 30 second timeout for commands
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        if (data.success) {
                            this.showToast(successMessage);
                            
                            // Auto-collapse Command Center after successful action (CMD-3-4)
                            this.hideVacuumPanel();
                            const commandCenter = document.getElementById('command-center');
                            commandCenter.classList.remove('open');
                        } else {
                            throw new Error(data.error || 'Command failed');
                        }
                    } else {
                        throw new Error(`HTTP ${response.status}`);
                    }
                } catch (error) {
                    console.error(`Vacuum ${command} failed:`, error.message);
                    
                    if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                        // API server not available
                        this.showToast('üîß API server needed - check setup instructions');
                        
                        // Show helpful information
                        const helpText = `To control Yiko:
1. cd /Users/agentcaras/.openclaw/workspace/alice-display-website
2. npm install && npm start
3. Refresh this page`;
                        
                        console.info(helpText);
                    } else {
                        this.showToast(`‚ùå ${error.message}`);
                    }
                } finally {
                    // Re-enable buttons and remove loading state
                    buttons.forEach(btn => {
                        btn.disabled = false;
                        btn.classList.remove('loading');
                    });
                    
                    // Reset button text
                    const startBtn = document.querySelector('.vacuum-btn-start span:last-child');
                    const stopBtn = document.querySelector('.vacuum-btn-stop span:last-child');
                    const homeBtn = document.querySelector('.vacuum-btn-home span:last-child');
                    
                    if (startBtn) startBtn.textContent = 'Start Cleaning';
                    if (stopBtn) stopBtn.textContent = 'Stop';
                    if (homeBtn) homeBtn.textContent = 'Go Home';
                }
            }
            
            initializeLightsPanel() {
                const lightsPanel = document.getElementById('lights-panel');
                const lightsClose = document.getElementById('lights-panel-close');
                const bedtimeBtn = document.getElementById('lights-bedtime');
                const daytimeBtn = document.getElementById('lights-daytime');
                const movieBtn = document.getElementById('lights-movie');
                
                // Close panel when close button clicked
                lightsClose.addEventListener('click', () => {
                    this.hideLightsPanel();
                });
                
                // Close panel when clicking outside
                lightsPanel.addEventListener('click', (e) => {
                    if (e.target === lightsPanel) {
                        this.hideLightsPanel();
                    }
                });
                
                // Bedtime preset
                bedtimeBtn.addEventListener('click', () => {
                    this.activateLightsPreset('bedtime');
                });
                
                // Daytime preset
                daytimeBtn.addEventListener('click', () => {
                    this.activateLightsPreset('daytime');
                });
                
                // Movie preset
                movieBtn.addEventListener('click', () => {
                    this.activateLightsPreset('movie');
                });
            }
            
            async showLightsPanel() {
                const panel = document.getElementById('lights-panel');
                
                // Lock body scroll when panel is open
                document.body.style.overflow = 'hidden';
                document.body.style.position = 'fixed';
                document.body.style.width = '100%';
                
                panel.classList.add('show');
            }
            
            hideLightsPanel() {
                const panel = document.getElementById('lights-panel');
                panel.classList.remove('show');
                
                // Restore body scroll
                document.body.style.overflow = '';
                document.body.style.position = '';
                document.body.style.width = '';
            }
            
            async activateLightsPreset(preset) {
                // Disable all buttons temporarily
                const buttons = document.querySelectorAll('.lights-preset-btn');
                buttons.forEach(btn => btn.disabled = true);
                
                try {
                    let message = '';
                    let icon = '';
                    
                    switch (preset) {
                        case 'bedtime':
                            message = 'Setting bedtime mode...';
                            icon = 'üåô';
                            break;
                        case 'daytime':
                            message = 'Setting daytime mode...';
                            icon = '‚òÄÔ∏è';
                            break;
                        case 'movie':
                            message = 'Setting movie mode...';
                            icon = 'üé¨';
                            break;
                    }
                    
                    this.showToast(message);
                    
                    // Send lights control request
                    const result = await this.sendLightsCommand(preset);
                    
                    if (result.success) {
                        // Auto-collapse Command Center and hide lights panel
                        this.hideLightsPanel();
                        document.getElementById('command-center').classList.remove('open');
                        
                        // Show success toast
                        this.showToast(`${icon} ${preset.charAt(0).toUpperCase() + preset.slice(1)} mode activated`);
                    } else {
                        this.showToast(`‚ùå Failed to set ${preset} mode: ${result.error}`);
                    }
                    
                } catch (error) {
                    console.error(`Error activating ${preset} preset:`, error);
                    this.showToast(`‚ùå Error: ${error.message}`);
                } finally {
                    // Re-enable buttons
                    buttons.forEach(btn => btn.disabled = false);
                }
            }
            
            async sendLightsCommand(preset) {
                try {
                    // Try to connect to local lights API server
                    // Run `npm start` in the alice-display-website directory to start the server
                    const response = await fetch('http://localhost:3001/api/lights', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            preset: preset,
                            timestamp: Date.now()
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                    const result = await response.json();
                    return result;
                    
                } catch (error) {
                    // Fallback: log the command for manual execution
                    console.warn('Could not reach lights API, logging command for manual execution:', error);
                    
                    // Generate the OpenHue commands for manual execution
                    const commands = this.generateOpenHueCommands(preset);
                    console.info('OpenHue commands to run manually:', commands);
                    
                    // For demo purposes, simulate success
                    return { 
                        success: true, 
                        message: 'Commands logged to console',
                        commands: commands
                    };
                }
            }
            
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            // IMAGE CONTROL PANEL METHODS
            // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            
            initializeImageControlPanel() {
                const panel = document.getElementById('image-control-panel');
                const closeBtn = document.getElementById('image-control-close');
                const backdrop = document.getElementById('image-control-backdrop');
                const changeBtn = document.getElementById('img-change');
                const reportBtn = document.getElementById('img-report');
                const likeBtn = document.getElementById('img-like');
                const dislikeBtn = document.getElementById('img-dislike');
                
                // Track current image rating state
                this.currentImageRating = null; // null, 'liked', or 'disliked'
                
                // Close panel
                closeBtn.addEventListener('click', () => this.hideImageControlPanel());
                backdrop.addEventListener('click', () => this.hideImageControlPanel());
                
                // Button actions
                changeBtn.addEventListener('click', () => this.handleChangeImage());
                reportBtn.addEventListener('click', () => {
                    this.hideImageControlPanel();
                    this.showReportModal();
                });
                likeBtn.addEventListener('click', () => this.handleRateImage(1));
                dislikeBtn.addEventListener('click', () => this.handleRateImage(-1));
                
                // Close with Escape
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && panel.classList.contains('show')) {
                        this.hideImageControlPanel();
                    }
                });
            }
            
            showImageControlPanel() {
                const panel = document.getElementById('image-control-panel');
                const backdrop = document.getElementById('image-control-backdrop');
                
                // Update rating button states based on current image
                this.updateRatingButtonStates();
                
                panel.classList.add('show');
                backdrop.classList.add('show');
            }
            
            hideImageControlPanel() {
                const panel = document.getElementById('image-control-panel');
                const backdrop = document.getElementById('image-control-backdrop');
                
                panel.classList.remove('show');
                backdrop.classList.remove('show');
            }
            
            updateRatingButtonStates() {
                const likeBtn = document.getElementById('img-like');
                const dislikeBtn = document.getElementById('img-dislike');
                
                // Check localStorage for existing rating on this image
                const imageId = this.currentData?.currentImage?.notion_id || this.currentData?.currentImage?.id;
                if (imageId) {
                    const ratings = JSON.parse(localStorage.getItem('aliceImageRatings') || '{}');
                    const rating = ratings[imageId];
                    
                    likeBtn.classList.toggle('active', rating === 1);
                    dislikeBtn.classList.toggle('active', rating === -1);
                    this.currentImageRating = rating || null;
                } else {
                    likeBtn.classList.remove('active');
                    dislikeBtn.classList.remove('active');
                    this.currentImageRating = null;
                }
            }
            
            async handleChangeImage() {
                const changeBtn = document.getElementById('img-change');
                const originalIcon = changeBtn.querySelector('.image-control-btn-icon').textContent;
                const originalText = changeBtn.querySelector('.image-control-btn-text').textContent;
                
                // Set loading state
                changeBtn.disabled = true;
                changeBtn.classList.add('loading');
                changeBtn.querySelector('.image-control-btn-text').textContent = 'Changing...';
                
                try {
                    // Get current image ID and context
                    const currentImageId = this.currentData?.currentImage?.notion_id || this.currentData?.currentImage?.id;
                    const context = {
                        weather: this.currentData?.weather?.condition || 'Sunny',
                        time_period: this.currentData?.time?.period || 'Afternoon',
                        hour: new Date().getHours()
                    };
                    
                    // Call the change image API (Vercel serverless function)
                    const API_BASE = 'https://alice-image-api.vercel.app';
                    const response = await fetch(`${API_BASE}/api/image/change`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            current_image_id: currentImageId,
                            context: context
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                    const result = await response.json();
                    
                    if (result.success && result.image) {
                        // Update display with new image
                        const newImageData = {
                            ...this.currentData,
                            currentImage: {
                                ...this.currentData?.currentImage,
                                url: result.image.cloudinary_url || result.image.url,
                                title: result.image.title,
                                notion_id: result.image.id,
                                activity: result.image.activity
                            }
                        };
                        
                        this.currentData = newImageData;
                        await this.updateDisplay(newImageData, true);
                        
                        // Success feedback
                        changeBtn.classList.add('success');
                        setTimeout(() => changeBtn.classList.remove('success'), 500);
                        this.showToast('üîÑ Image changed!');
                        
                        // Update rating buttons for new image
                        this.updateRatingButtonStates();
                        
                        // Auto-close after success
                        setTimeout(() => this.hideImageControlPanel(), 800);
                    } else {
                        throw new Error(result.message || 'No alternative images found');
                    }
                } catch (error) {
                    console.error('Change image error:', error);
                    changeBtn.classList.add('error');
                    setTimeout(() => changeBtn.classList.remove('error'), 500);
                    
                    if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                        this.showToast('üîß API not available - deploying soon!');
                    } else {
                        this.showToast(`‚ùå ${error.message}`);
                    }
                } finally {
                    // Reset button state
                    changeBtn.disabled = false;
                    changeBtn.classList.remove('loading');
                    changeBtn.querySelector('.image-control-btn-icon').textContent = originalIcon;
                    changeBtn.querySelector('.image-control-btn-text').textContent = originalText;
                }
            }
            
            async handleRateImage(rating) {
                const likeBtn = document.getElementById('img-like');
                const dislikeBtn = document.getElementById('img-dislike');
                const activeBtn = rating === 1 ? likeBtn : dislikeBtn;
                
                // If already rated same way, this is an "unrate"
                const imageId = this.currentData?.currentImage?.notion_id || this.currentData?.currentImage?.id;
                if (!imageId) {
                    this.showToast('‚ö†Ô∏è No image to rate');
                    return;
                }
                
                // Check if clicking same rating (toggle off)
                if (this.currentImageRating === rating) {
                    // Remove rating
                    this.saveRatingLocally(imageId, null);
                    this.currentImageRating = null;
                    likeBtn.classList.remove('active');
                    dislikeBtn.classList.remove('active');
                    this.showToast('Rating removed');
                    return;
                }
                
                // Set loading state
                activeBtn.disabled = true;
                activeBtn.classList.add('loading');
                
                try {
                    // Save locally first (optimistic update)
                    this.saveRatingLocally(imageId, rating);
                    this.currentImageRating = rating;
                    
                    // Update UI immediately
                    likeBtn.classList.toggle('active', rating === 1);
                    dislikeBtn.classList.toggle('active', rating === -1);
                    
                    // Try to submit to server (Vercel serverless function)
                    const API_BASE_RATE = 'https://alice-image-api.vercel.app';
                    const response = await fetch(`${API_BASE_RATE}/api/image/rate`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            image_id: imageId,
                            rating: rating,
                            context: {
                                timestamp: new Date().toISOString(),
                                weather: this.currentData?.weather?.condition,
                                time_period: this.currentData?.time?.period,
                                user_agent: navigator.userAgent,
                                session_id: this.getSessionId()
                            }
                        })
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        console.log('Rating submitted:', result);
                    } else {
                        console.warn('Server rating failed, but saved locally');
                    }
                    
                    // Success feedback
                    activeBtn.classList.add('success');
                    setTimeout(() => activeBtn.classList.remove('success'), 500);
                    this.showToast(rating === 1 ? 'üëç Liked!' : 'üëé Disliked');
                    
                } catch (error) {
                    console.warn('Rating API error (saved locally):', error);
                    // Still show success since we saved locally
                    activeBtn.classList.add('success');
                    setTimeout(() => activeBtn.classList.remove('success'), 500);
                    this.showToast(rating === 1 ? 'üëç Liked! (saved locally)' : 'üëé Disliked (saved locally)');
                } finally {
                    activeBtn.disabled = false;
                    activeBtn.classList.remove('loading');
                }
            }
            
            saveRatingLocally(imageId, rating) {
                const ratings = JSON.parse(localStorage.getItem('aliceImageRatings') || '{}');
                if (rating === null) {
                    delete ratings[imageId];
                } else {
                    ratings[imageId] = rating;
                }
                localStorage.setItem('aliceImageRatings', JSON.stringify(ratings));
            }
            
            getSessionId() {
                let sessionId = sessionStorage.getItem('aliceSessionId');
                if (!sessionId) {
                    sessionId = 'sess_' + Math.random().toString(36).substring(2, 15);
                    sessionStorage.setItem('aliceSessionId', sessionId);
                }
                return sessionId;
            }
            
            generateOpenHueCommands(preset) {
                const lightIds = [
                    "6a704bb0-d201-4343-8939-3cd98ee80643", // Kitchen fan 3-24
                    "2923d843-cf08-4ed8-aa79-27c722c08bbe", // Kitchen BW fan
                    "24da2926-210d-4b34-af37-7ecbf613b576", // Kitchen fan 2- 3/24
                    "1c124fbc-0d5f-4d3d-b84c-35fe208cff84", // Kitchen high lamp
                    "aa86140d-999d-465e-8c90-ba4d64664e72", // Zahava lamp
                    "a02ac2d6-482e-48c9-9f39-397008b6670a", // Outside Flood
                    "f0390f66-031a-4131-83de-b31b3fa9a05b", // Hue color lamp 2
                    "741900cf-413a-43e3-be6c-6a3f49c23cfb", // Hue color lamp 1
                    "9376f857-21b9-4a96-9cf4-92cd50cf987d", // Dining room fan - 4/24
                    "9993b466-9fcd-436e-8d78-1e7d835f7b80", // Living room lamp 3/24
                    "0dc211bd-b00a-42b6-b484-e49dbe79d05e", // Living room fan 3-24 #2
                    "9bd2567a-1683-4eeb-83c7-c66f2b214873", // Downstairs entrance 2
                    "fd64c7ac-4a70-4015-87d4-48264e7a9631", // fan above table
                    "c3edaddf-d9a0-4277-ad19-9a5ad8b3085c", // Dinning room March 23
                    "ebf4d80f-5b73-4a08-84a2-0250808f5533", // Living Room Fan 2
                    "ca5e5869-8b91-4135-94e7-69277f8d4beb", // Downstairs entrance 1
                    "9f2037a2-116c-4147-96a1-d6098fc44a03", // dinning room strip
                    "4122d13e-0c3e-4a06-b752-4b90add03a6f", // Living room tv strip
                    "dfc85340-54aa-44e1-82a4-4b6d2d46a8b4", // living room piano
                    "7e629fd1-c5c3-4e59-b650-b7d0f342ce7c", // Master bedroom left July 22
                    "5c0681a9-d2f9-4716-8844-4d91e996deac", // master bed left
                    "346c7450-096e-4857-b0a0-887ef98c3e8b"  // master bed right
                ];
                
                let commands = [];
                
                switch (preset) {
                    case 'bedtime':
                        // Set all lights to 1% brightness
                        lightIds.forEach(lightId => {
                            commands.push(`openhue set light "${lightId}" --on --brightness 1`);
                        });
                        break;
                        
                    case 'daytime':
                        // Set all lights to 100% brightness
                        lightIds.forEach(lightId => {
                            commands.push(`openhue set light "${lightId}" --on --brightness 100`);
                        });
                        break;
                        
                    case 'movie':
                        // Set all lights to 30% brightness, add blue color for color-capable lights
                        const colorCapableLights = [
                            "6a704bb0-d201-4343-8939-3cd98ee80643", // Kitchen fan 3-24
                            "24da2926-210d-4b34-af37-7ecbf613b576", // Kitchen fan 2- 3/24
                            "1c124fbc-0d5f-4d3d-b84c-35fe208cff84", // Kitchen high lamp
                            "aa86140d-999d-465e-8c90-ba4d64664e72", // Zahava lamp
                            "a02ac2d6-482e-48c9-9f39-397008b6670a", // Outside Flood
                            "f0390f66-031a-4131-83de-b31b3fa9a05b", // Hue color lamp 2
                            "741900cf-413a-43e3-be6c-6a3f49c23cfb", // Hue color lamp 1
                            "9376f857-21b9-4a96-9cf4-92cd50cf987d", // Dining room fan - 4/24
                            "9993b466-9fcd-436e-8d78-1e7d835f7b80", // Living room lamp 3/24
                            "0dc211bd-b00a-42b6-b484-e49dbe79d05e", // Living room fan 3-24 #2
                            "fd64c7ac-4a70-4015-87d4-48264e7a9631", // fan above table
                            "c3edaddf-d9a0-4277-ad19-9a5ad8b3085c", // Dinning room March 23
                            "ebf4d80f-5b73-4a08-84a2-0250808f5533", // Living Room Fan 2
                            "9f2037a2-116c-4147-96a1-d6098fc44a03", // dinning room strip
                            "4122d13e-0c3e-4a06-b752-4b90add03a6f", // Living room tv strip
                            "dfc85340-54aa-44e1-82a4-4b6d2d46a8b4", // living room piano
                            "7e629fd1-c5c3-4e59-b650-b7d0f342ce7c", // Master bedroom left July 22
                            "5c0681a9-d2f9-4716-8844-4d91e996deac", // master bed left
                            "346c7450-096e-4857-b0a0-887ef98c3e8b"  // master bed right
                        ];
                        
                        lightIds.forEach(lightId => {
                            if (colorCapableLights.includes(lightId)) {
                                commands.push(`openhue set light "${lightId}" --on --brightness 30 --color blue`);
                            } else {
                                commands.push(`openhue set light "${lightId}" --on --brightness 30`);
                            }
                        });
                        break;
                }
                
                return commands;
            }
            
            initializeAboutPanel() {
                const aboutPanel = document.getElementById('about-panel');
                const aboutClose = document.getElementById('about-panel-close');
                
                // Close panel when close button clicked
                aboutClose.addEventListener('click', () => {
                    this.hideAboutPanel();
                });
                
                // Close panel when clicking outside
                aboutPanel.addEventListener('click', (e) => {
                    if (e.target === aboutPanel) {
                        this.hideAboutPanel();
                    }
                });
                
                // Close panel with Escape key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && aboutPanel.classList.contains('show')) {
                        this.hideAboutPanel();
                    }
                });
                
                // Load version info on initialization
                this.loadVersionInfo();
            }
            
            async showAboutPanel() {
                const panel = document.getElementById('about-panel');
                
                // Lock body scroll when panel is open
                document.body.style.overflow = 'hidden';
                document.body.style.position = 'fixed';
                document.body.style.width = '100%';
                
                panel.classList.add('show');
                
                // Update info when panel opens
                this.updateAboutInfo();
            }
            
            hideAboutPanel() {
                const panel = document.getElementById('about-panel');
                panel.classList.remove('show');
                
                // Restore body scroll
                document.body.style.overflow = '';
                document.body.style.position = '';
                document.body.style.width = '';
            }
            
            async loadVersionInfo() {
                try {
                    const response = await fetch('version.json');
                    if (response.ok) {
                        this.versionInfo = await response.json();
                    } else {
                        this.versionInfo = { commit: 'unknown', deployedAt: 'unknown' };
                    }
                } catch (error) {
                    console.warn('Could not load version info:', error);
                    this.versionInfo = { commit: 'unknown', deployedAt: 'unknown' };
                }
                
                // Update the display if version info is already shown
                if (document.getElementById('about-panel').classList.contains('show')) {
                    this.updateAboutInfo();
                }
            }
            
            updateAboutInfo() {
                // Version info
                if (this.versionInfo) {
                    document.getElementById('about-version-commit').textContent = this.versionInfo.commit || 'unknown';
                    document.getElementById('about-version-deployed').textContent = this.versionInfo.deployedAt || 'unknown';
                }
                
                // Current image info
                if (this.currentData && this.currentData.currentImage) {
                    const imageUrl = this.currentData.currentImage.url || '';
                    const filename = imageUrl.split('/').pop() || '--';
                    document.getElementById('about-image-filename').textContent = filename;
                    document.getElementById('about-image-activity').textContent = this.currentData.currentImage.activity || '--';
                } else {
                    document.getElementById('about-image-filename').textContent = '--';
                    document.getElementById('about-image-activity').textContent = '--';
                }
                
                // Context info
                if (this.currentData) {
                    document.getElementById('about-weather').textContent = 
                        this.currentData.weather?.condition || '--';
                    document.getElementById('about-temperature').textContent = 
                        this.currentData.weather?.temperature ? `${Math.round(this.currentData.weather.temperature)}¬∞C` : '--';
                    document.getElementById('about-time-period').textContent = 
                        this.currentData.time?.period || '--';
                    document.getElementById('about-last-update').textContent = 
                        this.lastUpdated || '--';
                }
                
                // System info
                document.getElementById('about-screen').textContent = `${window.innerWidth}√ó${window.innerHeight}`;
                document.getElementById('about-browser').textContent = this.getBrowserInfo();
                document.getElementById('about-platform').textContent = this.getPlatformInfo();
                document.getElementById('about-connection').textContent = 
                    navigator.onLine ? (this.usingFallback ? 'Fallback' : 'Online') : 'Offline';
            }
            
            getBrowserInfo() {
                const ua = navigator.userAgent;
                if (/CriOS/.test(ua)) return 'iOS Chrome';
                if (/Safari/.test(ua) && !/Chrome/.test(ua)) return 'Safari';
                if (/Chrome/.test(ua) && !/Edge/.test(ua)) return 'Chrome';
                if (/Firefox/.test(ua)) return 'Firefox';
                if (/Edge/.test(ua)) return 'Edge';
                return 'Unknown';
            }
            
            getPlatformInfo() {
                const ua = navigator.userAgent;
                if (/iPad|iPhone|iPod/.test(ua)) return 'iOS';
                if (/Android/.test(ua)) return 'Android';
                if (/Mac/.test(ua)) return 'macOS';
                if (/Win/.test(ua)) return 'Windows';
                if (/Linux/.test(ua)) return 'Linux';
                return navigator.platform || 'Unknown';
            }
            
            closeAllPanels() {
                document.getElementById('help-overlay').classList.remove('show');
                document.getElementById('image-info').classList.remove('show');
                document.getElementById('report-modal').classList.remove('show');
                document.getElementById('vacuum-panel').classList.remove('show');
                document.getElementById('lights-panel').classList.remove('show');
                document.getElementById('image-control-panel').classList.remove('show');
                document.getElementById('image-control-backdrop').classList.remove('show');
                document.getElementById('about-panel').classList.remove('show');
                // Note: status overlay toggle is separate - not included in close all panels
                this.debugEl.classList.remove('show');
            }
            
            showToast(message) {
                const toast = document.getElementById('toast');
                toast.textContent = message;
                toast.classList.add('show');
                setTimeout(() => {
                    toast.classList.remove('show');
                }, 1500);
            }
            
            startPolling() {
                // Update countdown display
                let nextPoll = Date.now() + this.pollInterval;
                
                const updateCountdown = () => {
                    const remaining = Math.max(0, Math.ceil((nextPoll - Date.now()) / 1000));
                    const mins = Math.floor(remaining / 60);
                    const secs = remaining % 60;
                    this.countdownEl.textContent = `Next check in ${mins}:${secs.toString().padStart(2, '0')}`;
                };
                
                setInterval(updateCountdown, 1000);
                
                // Main polling loop
                setInterval(() => {
                    if (!this.isPaused) {
                        this.loadDisplay();
                    }
                    nextPoll = Date.now() + this.pollInterval;
                }, this.pollInterval);
                
                console.log('ü¶ú Alice Display initialized');
                console.log(`üì° Auto-refresh every ${this.pollInterval / 1000 / 60} minutes`);
            }
        }
        
        // Browser Detection Utility
        const BrowserDetect = {
            // Detect Safari (including iOS Safari)
            isSafari: () => {
                const ua = navigator.userAgent;
                const isSafari = /^((?!chrome|android).)*safari/i.test(ua);
                const isIOSSafari = /iPad|iPhone|iPod/.test(ua) && !window.MSStream;
                return isSafari || isIOSSafari;
            },
            
            // Detect Chrome (including iOS Chrome)
            isChrome: () => {
                const ua = navigator.userAgent;
                return /chrome/i.test(ua) && !/edge/i.test(ua);
            },
            
            // Detect iOS (any browser)
            isIOS: () => {
                return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
            },
            
            // Detect iOS Chrome (uses Safari WebKit underneath)
            isIOSChrome: () => {
                return /CriOS/.test(navigator.userAgent);
            },
            
            // Detect Android
            isAndroid: () => {
                return /android/i.test(navigator.userAgent);
            },
            
            // Get browser name
            getBrowser: () => {
                if (BrowserDetect.isIOSChrome()) return 'ios-chrome';
                if (BrowserDetect.isSafari()) return 'safari';
                if (BrowserDetect.isChrome()) return 'chrome';
                return 'other';
            },
            
            // Get platform
            getPlatform: () => {
                if (BrowserDetect.isIOS()) return 'ios';
                if (BrowserDetect.isAndroid()) return 'android';
                return 'desktop';
            },
            
            // Apply classes to body
            applyClasses: () => {
                const browser = BrowserDetect.getBrowser();
                const platform = BrowserDetect.getPlatform();
                
                document.body.classList.add(`browser-${browser}`);
                document.body.classList.add(`platform-${platform}`);
                
                // Log for debugging
                console.log(`üåê Browser: ${browser}, Platform: ${platform}`);
            }
        };
        
        // Initialize on DOM ready
        document.addEventListener('DOMContentLoaded', () => {
            // Apply browser detection classes first
            BrowserDetect.applyClasses();
            
            // DIRECT FIX: Force command center position on iOS Safari portrait
            // Match status-overlay position (cloud icon) at bottom: 20px
            if (BrowserDetect.isIOS() && window.innerWidth <= 480 && window.innerHeight > window.innerWidth) {
                const commandCenter = document.getElementById('command-center');
                if (commandCenter) {
                    commandCenter.style.cssText = 'position: fixed !important; bottom: 15px !important; top: auto !important; right: 20px !important;';
                    console.log('üì± iOS Safari portrait fix applied: bottom=15px');
                }
            }
            
            // Initialize display
            new AliceDisplay();
        });
        
        // PWA Install Prompt Handler
        class InstallPrompt {
            constructor() {
                this.deferredPrompt = null;
                this.banner = document.getElementById('install-banner');
                this.installBtn = document.getElementById('install-btn');
                this.dismissBtn = document.getElementById('install-dismiss');
                this.iosModal = document.getElementById('ios-modal');
                this.iosModalClose = document.getElementById('ios-modal-close');
                
                this.init();
            }
            
            init() {
                // Check if already installed or dismissed
                if (this.isInstalled() || this.isDismissed()) {
                    return;
                }
                
                // Check for iOS
                if (this.isIOS()) {
                    this.setupIOSPrompt();
                    return;
                }
                
                // Listen for beforeinstallprompt (Chrome/Edge)
                window.addEventListener('beforeinstallprompt', (e) => {
                    e.preventDefault();
                    this.deferredPrompt = e;
                    this.showBanner();
                });
                
                // Handle install button click
                this.installBtn.addEventListener('click', () => this.handleInstall());
                this.dismissBtn.addEventListener('click', () => this.handleDismiss());
                
                // Listen for successful install
                window.addEventListener('appinstalled', () => {
                    console.log('ü¶ú App installed successfully!');
                    this.hideBanner();
                    this.deferredPrompt = null;
                });
            }
            
            isInstalled() {
                // Check if running as installed PWA
                return window.matchMedia('(display-mode: standalone)').matches ||
                       window.navigator.standalone === true;
            }
            
            isDismissed() {
                const dismissed = localStorage.getItem('installDismissed');
                if (!dismissed) return false;
                
                // Allow re-prompting after 7 days
                const dismissedTime = parseInt(dismissed, 10);
                const sevenDays = 7 * 24 * 60 * 60 * 1000;
                return (Date.now() - dismissedTime) < sevenDays;
            }
            
            isIOS() {
                return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
            }
            
            isIPad() {
                return /iPad/.test(navigator.userAgent) || 
                       (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            }
            
            isIOSSafari() {
                const ua = navigator.userAgent;
                const iOS = /iPad|iPhone|iPod/.test(ua);
                const webkit = /WebKit/.test(ua);
                const notChrome = !/CriOS/.test(ua);
                const notFirefox = !/FxiOS/.test(ua);
                const notEdge = !/EdgiOS/.test(ua);
                return iOS && webkit && notChrome && notFirefox && notEdge;
            }
            
            setupIOSPrompt() {
                // Get additional iOS modal elements
                const iosModalDismiss = document.getElementById('ios-modal-dismiss');
                const safariNote = this.iosModal.querySelector('.ios-safari-note');
                
                // Update note if not in Safari
                if (!this.isIOSSafari() && safariNote) {
                    safariNote.innerHTML = `
                        <strong>‚ö†Ô∏è Open in Safari</strong><br>
                        You're not in Safari. Copy this link and open it in Safari to install:
                        <div id="safari-url-copy" style="margin-top:8px;padding:10px;background:rgba(255,255,255,0.1);border-radius:6px;font-size:11px;word-break:break-all;cursor:pointer;-webkit-tap-highlight-color:transparent;transition:background 0.15s ease;position:relative;">
                            ${window.location.href}
                            <div id="url-copy-toast" style="position:absolute;top:-30px;left:50%;transform:translateX(-50%);background:rgba(34,197,94,0.9);color:white;padding:4px 12px;border-radius:8px;font-size:11px;white-space:nowrap;pointer-events:none;opacity:0;transition:opacity 0.25s ease;">üìã Copied!</div>
                        </div>
                    `;
                    safariNote.style.color = 'rgba(255, 200, 100, 0.8)';
                    
                    // Make the URL text tappable to copy to clipboard
                    const urlCopyEl = document.getElementById('safari-url-copy');
                    if (urlCopyEl) {
                        urlCopyEl.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const siteUrl = window.location.href;
                            const toast = document.getElementById('url-copy-toast');
                            
                            // Flash the background to show tap feedback
                            urlCopyEl.style.background = 'rgba(255,255,255,0.25)';
                            setTimeout(() => { urlCopyEl.style.background = 'rgba(255,255,255,0.1)'; }, 200);
                            
                            // Copy to clipboard
                            if (navigator.clipboard && navigator.clipboard.writeText) {
                                navigator.clipboard.writeText(siteUrl).then(() => {
                                    if (toast) { toast.style.opacity = '1'; setTimeout(() => { toast.style.opacity = '0'; }, 1500); }
                                }).catch(() => {
                                    // Fallback for non-HTTPS or permission denied
                                    const ta = document.createElement('textarea');
                                    ta.value = siteUrl;
                                    ta.style.cssText = 'position:fixed;opacity:0';
                                    document.body.appendChild(ta);
                                    ta.select();
                                    document.execCommand('copy');
                                    document.body.removeChild(ta);
                                    if (toast) { toast.style.opacity = '1'; setTimeout(() => { toast.style.opacity = '0'; }, 1500); }
                                });
                            } else {
                                // Fallback
                                const ta = document.createElement('textarea');
                                ta.value = siteUrl;
                                ta.style.cssText = 'position:fixed;opacity:0';
                                document.body.appendChild(ta);
                                ta.select();
                                document.execCommand('copy');
                                document.body.removeChild(ta);
                                if (toast) { toast.style.opacity = '1'; setTimeout(() => { toast.style.opacity = '0'; }, 1500); }
                            }
                        });
                    }
                }
                
                // Update text for iPad
                if (this.isIPad()) {
                    const stepDesc = this.iosModal.querySelector('.ios-step-desc');
                    if (stepDesc) {
                        stepDesc.textContent = 'Find it at the top of Safari';
                    }
                }
                
                // Show banner after a short delay on iOS
                setTimeout(() => {
                    this.showBanner();
                }, 3000);
                
                this.installBtn.addEventListener('click', () => {
                    this.iosModal.classList.add('show');
                    this.hideBanner();
                });
                
                this.dismissBtn.addEventListener('click', () => this.handleDismiss());
                
                // "Got it" button - just closes modal
                this.iosModalClose.addEventListener('click', () => {
                    this.iosModal.classList.remove('show');
                });
                
                // "Don't show again" button - closes and permanently dismisses
                if (iosModalDismiss) {
                    iosModalDismiss.addEventListener('click', () => {
                        this.iosModal.classList.remove('show');
                        // Set a very long dismissal (365 days)
                        const oneYear = 365 * 24 * 60 * 60 * 1000;
                        localStorage.setItem('installDismissed', (Date.now() + oneYear).toString());
                    });
                }
                
                // Close modal on backdrop click
                this.iosModal.addEventListener('click', (e) => {
                    if (e.target === this.iosModal) {
                        this.iosModal.classList.remove('show');
                    }
                });
                
                // Close modal with Escape key
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.iosModal.classList.contains('show')) {
                        this.iosModal.classList.remove('show');
                    }
                });
            }
            
            showBanner() {
                // Delay showing to not interrupt initial experience
                setTimeout(() => {
                    this.banner.classList.add('show');
                }, 5000);
            }
            
            hideBanner() {
                this.banner.classList.remove('show');
            }
            
            async handleInstall() {
                if (!this.deferredPrompt) {
                    console.log('No install prompt available');
                    return;
                }
                
                // Show the install prompt
                this.deferredPrompt.prompt();
                
                // Wait for user response
                const { outcome } = await this.deferredPrompt.userChoice;
                console.log(`Install prompt outcome: ${outcome}`);
                
                this.deferredPrompt = null;
                this.hideBanner();
            }
            
            handleDismiss() {
                localStorage.setItem('installDismissed', Date.now().toString());
                this.hideBanner();
            }
        }
        
        // Initialize install prompt
        new InstallPrompt();
        
        // Register service worker for offline support
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then((registration) => {
                        console.log('ü¶ú Service Worker registered:', registration.scope);
                        
                        // Check for updates periodically
                        setInterval(() => {
                            registration.update();
                        }, 60 * 60 * 1000);  // Check hourly
                        
                        // Handle updates
                        registration.addEventListener('updatefound', () => {
                            const newWorker = registration.installing;
                            newWorker.addEventListener('statechange', () => {
                                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                    console.log('ü¶ú New version available');
                                    // Optionally notify user or auto-update
                                    newWorker.postMessage({ type: 'SKIP_WAITING' });
                                }
                            });
                        });
                    })
                    .catch((error) => {
                        console.warn('Service Worker registration failed:', error);
                    });
                
                // Listen for controller changes (new SW activated)
                navigator.serviceWorker.addEventListener('controllerchange', () => {
                    console.log('ü¶ú Service Worker updated, reloading...');
                    window.location.reload();
                });
            });
        }
    </script>
</body>
</html>
